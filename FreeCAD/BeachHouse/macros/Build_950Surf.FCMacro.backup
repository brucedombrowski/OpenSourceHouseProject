import FreeCAD as App
import Part
import os
import sys
import csv
import math

def inch(x): return x * 25.4
def ft(x): return inch(x * 12.0)

# Lot parameters
lot_x_ft = 50.0
lot_y_ft = 100.0
side_setback_ft = 5.0
front_setback_ft = 20.0

# Pile parameters
pile_label = "12x12x40_piling_PT"
pile_thick_in = 11.25
pile_width_in = 11.25
pile_len_in = 480.0  # 40'
embed_depth_ft = 20.0
above_grade_ft = 20.0
pile_base_z_in = -embed_depth_ft * 12.0  # start at -20'
# Grid: center pile at lot mid (25'); X spacing 8'; user-configurable counts
half_pile_w_ft = pile_width_in / 24.0  # half width in feet (11.25"/12/2)
num_piles_x = 5
num_piles_y = 6
# X positions centered on lot midpoint with fixed 8' spacing
center_x_ft = lot_x_ft / 2.0
x_spacing_ft = 8.0
x_offsets = [-(x_spacing_ft * 2), -x_spacing_ft, 0.0, x_spacing_ft, x_spacing_ft * 2]
x_positions_ft = [center_x_ft + off for off in x_offsets]
# Y rows start so front pile face sits at the front setback (20'), spacing 8'
y_spacing_ft = 8.0
start_y_ft = front_setback_ft + (pile_thick_in / 24.0)  # center shifted so face = setback
y_positions_ft = [start_y_ft + i * y_spacing_ft for i in range(num_piles_y)]

# Beam parameters (2x12x16 running along Y)
beam_label = "beam_2x12x192_PT"
beam_thick_in = 1.5
beam_depth_in = 11.25
beam_len_in = 192.0  # 16'
beam_row_step = 3  # every 3 rows; spans 3 rows at 8' spacing
beam_top_z_in = pile_base_z_in + pile_len_in  # align with pile top
beam_base_z_in = beam_top_z_in - beam_depth_in
beam_gap_in = 0.0  # optional gap for double beams on pile faces
# Mid-span board between specific rows
mid_board_len_in = 96.0  # 8'
mid_board_thick_in = beam_thick_in
mid_board_depth_in = beam_depth_in
mid_board_offset_L_in = beam_thick_in       # +1.5" for left
mid_board_offset_R_in = -(beam_thick_in * 2.0)  # -3.0" for right (adds another 0.75")
mid_blocking_offsets_ft = [4.0]  # blocking positions along Y for midboards
mid_board_label = "beam_2x12x96_PT"
# Blocking between double beams (bridging left/right)
blocking_thick_in = beam_thick_in
blocking_depth_in = beam_depth_in
blocking_offsets_ft = [4.0, 12.0]  # positions along Y from beam start

# Joist module (16x16, 2x12 joists at 16" OC), placed with left edge at center-front (25',20')
module_x_ft = 16.0
module_y_ft = 16.0
module_first_spacing_in = 14.5   # front rim -> joist 0
module_joist_spacing_in = 16.0   # remaining bays
module_joist_label = "joist_2x12_PT"
module_left_x_ft = lot_x_ft / 2.0  # align right module to lot center baseline
module_front_y_ft = front_setback_ft  # align front to buildable front line
module_base_z_ft = above_grade_ft  # bottom of joists at 20' above grade
sheathing_thick_in = 0.75
sheathing_label = "panel_advantech_4x8"
# Hanger parameters (Simpson LU210 approximated)
hanger_label = "hanger_LU210"
hanger_thickness_in = 0.06
hanger_height_in = 7.8125
hanger_seat_depth_in = 2.0
hanger_color = None

# Catalog lookup (for metadata)
macro_dir = os.path.dirname(__file__)
# Point to shared lumber helpers (lives at FreeCAD/lumber)
lumber_dir = os.path.abspath(os.path.join(macro_dir, "..", "..", "lumber"))
if lumber_dir not in sys.path:
    sys.path.append(lumber_dir)
try:
    import lumber_common as lc
except Exception:
    lc = None
def load_catalog(paths):
    merged = {}
    for path in paths:
        if not os.path.isfile(path):
            continue
        with open(path, newline="") as f:
            for row in csv.DictReader(f):
                merged[row["label"]] = row  # later files override earlier
    return merged

catalog = load_catalog([
    os.path.join(os.path.dirname(macro_dir), "lumber", "catalog.csv"),  # shared lumber catalog
    os.path.join(macro_dir, "catalog.csv"),  # house-specific overrides
])

doc = App.newDocument("950Surf")

def add_poly(name, pts):
    wire = Part.makePolygon(pts)
    obj = doc.addObject("Part::Feature", name)
    obj.Shape = wire
    return obj

# Lot boundary
lot_pts = [
    App.Vector(0, 0, 0),
    App.Vector(ft(lot_x_ft), 0, 0),
    App.Vector(ft(lot_x_ft), ft(lot_y_ft), 0),
    App.Vector(0, ft(lot_y_ft), 0),
    App.Vector(0, 0, 0),
]
lot_obj = add_poly("Lot_Boundary", lot_pts)

# Buildable area
buildable_pts = [
    App.Vector(ft(side_setback_ft), ft(front_setback_ft), 0),
    App.Vector(ft(lot_x_ft - side_setback_ft), ft(front_setback_ft), 0),
    App.Vector(ft(lot_x_ft - side_setback_ft), ft(lot_y_ft), 0),
    App.Vector(ft(side_setback_ft), ft(lot_y_ft), 0),
    App.Vector(ft(side_setback_ft), ft(front_setback_ft), 0),
]
buildable_obj = add_poly("Buildable_Area", buildable_pts)

# Origin marker
cross = []
cross.append(Part.makeLine(App.Vector(-ft(1.0), 0, 0), App.Vector(ft(1.0), 0, 0)))
cross.append(Part.makeLine(App.Vector(0, -ft(1.0), 0), App.Vector(0, ft(1.0), 0)))
cross_obj = doc.addObject("Part::Feature", "Origin_Marker")
cross_obj.Shape = Part.Compound(cross)

# Piles
pile_objs = []
for xi_ft in x_positions_ft:
    for yi_ft in y_positions_ft:
        box = Part.makeBox(
            inch(pile_width_in),
            inch(pile_thick_in),
            inch(above_grade_ft * 12.0 - pile_base_z_in)  # total height from base to top
        )
        obj = doc.addObject("Part::Feature", f"Pile_{int(xi_ft)}_{int(yi_ft)}")
        obj.Shape = box
        # Center piles on grid points: subtract half width/thickness from base placement
        obj.Placement.Base = App.Vector(
            ft(xi_ft) - inch(pile_width_in / 2.0),
            ft(yi_ft) - inch(pile_thick_in / 2.0),
            inch(pile_base_z_in)
        )
        # Metadata from catalog
        if pile_label in catalog:
            row = catalog[pile_label]
            for prop in ("supplier", "sku", "url"):
                val = row.get(prop)
                if val:
                    if prop not in obj.PropertiesList:
                        obj.addProperty("App::PropertyString", prop)
                    obj.__setattr__(prop, val)
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = pile_label
        if "cut_length_in" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "cut_length_in")
        obj.cut_length_in = str(pile_len_in)
        pile_objs.append(obj)

# Beams along Y (2x12x16), sitting on pile tops, spanning 3 rows (24' of rows, 16' board centered on middle row)
beam_objs = []
blocking_objs = []
midboard_objs = []
for xi_ft in x_positions_ft:
    rows = list(range(0, max(0, len(y_positions_ft) - 2), beam_row_step))
    for r in rows:
        y_center_ft = y_positions_ft[r + 1]  # middle row of the trio
        # Beams run along Y; at 8' spacing, 16' beams cover 3 rows (2 intervals = 16')
        base_y = ft(y_center_ft) - ft(beam_len_in / 12.0 / 2.0)
        base_z = inch(beam_base_z_in)

        # Left beam: on left edge of pile (pile face minus beam thickness)
        base_x_left = ft(xi_ft) - inch(pile_width_in / 2.0) - inch(beam_thick_in) - inch(beam_gap_in)
        base_x_left += inch(beam_thick_in)  # shift inside notch
        box = Part.makeBox(
            inch(beam_thick_in),
            inch(beam_len_in),
            inch(beam_depth_in)
        )
        bL = doc.addObject("Part::Feature", f"Beam_{int(xi_ft)}_{r}_L")
        bL.Shape = box
        bL.Placement.Base = App.Vector(base_x_left, base_y, base_z)
        if "label" not in bL.PropertiesList:
            bL.addProperty("App::PropertyString", "label")
        bL.label = beam_label
        if beam_label in catalog:
            row = catalog[beam_label]
            for prop in ("supplier", "sku", "url"):
                val = row.get(prop)
                if val:
                    if prop not in bL.PropertiesList:
                        bL.addProperty("App::PropertyString", prop)
                    bL.__setattr__(prop, val)
        if "cut_length_in" not in bL.PropertiesList:
            bL.addProperty("App::PropertyString", "cut_length_in")
        bL.cut_length_in = str(beam_len_in)
        beam_objs.append(bL)

        # Right beam: on right edge of pile (pile face)
        base_x_right = ft(xi_ft) + inch(pile_width_in / 2.0) + inch(beam_gap_in)
        base_x_right -= inch(beam_thick_in)  # shift inside notch
        bR = doc.addObject("Part::Feature", f"Beam_{int(xi_ft)}_{r}_R")
        bR.Shape = box
        bR.Placement.Base = App.Vector(base_x_right, base_y, base_z)
        if "label" not in bR.PropertiesList:
            bR.addProperty("App::PropertyString", "label")
        bR.label = beam_label
        if beam_label in catalog:
            row = catalog[beam_label]
            for prop in ("supplier", "sku", "url"):
                val = row.get(prop)
                if val:
                    if prop not in bR.PropertiesList:
                        bR.addProperty("App::PropertyString", prop)
                    bR.__setattr__(prop, val)
        if "cut_length_in" not in bR.PropertiesList:
            bR.addProperty("App::PropertyString", "cut_length_in")
        bR.cut_length_in = str(beam_len_in)
        beam_objs.append(bR)

        # Blocking between left/right beams at specified offsets along Y
        gap_x_mm = inch(pile_width_in - 2 * beam_thick_in)  # clear gap inside pile notch
        block_len_mm = max(gap_x_mm, inch(1.0))
        block_base_x = base_x_left + inch(beam_thick_in)  # start after left beam thickness
        for off_ft in blocking_offsets_ft:
            block_base_y = base_y + inch(off_ft * 12.0) - inch(blocking_thick_in / 2.0)
            block_base_z = base_z
            block = Part.makeBox(
                block_len_mm,
                inch(blocking_thick_in),
                inch(blocking_depth_in)
            )
            blk = doc.addObject("Part::Feature", f"Blocking_{int(xi_ft)}_{r}_{int(off_ft)}")
            blk.Shape = block
            blk.Placement.Base = App.Vector(block_base_x, block_base_y, block_base_z)
            if "label" not in blk.PropertiesList:
                blk.addProperty("App::PropertyString", "label")
            blk.label = beam_label  # treat as 2x12 PT material
            if beam_label in catalog:
                row = catalog[beam_label]
                for prop in ("supplier", "sku", "url"):
                    val = row.get(prop)
                    if val:
                        if prop not in blk.PropertiesList:
                            blk.addProperty("App::PropertyString", prop)
                        blk.__setattr__(prop, val)
            blocking_objs.append(blk)

# Mid-span 8' boards between 3rd and 4th row (rows index 2 and 3), along Y on each X line
if len(y_positions_ft) >= 4:
    y_mid_ft = (y_positions_ft[2] + y_positions_ft[3]) / 2.0
    for xi_ft in x_positions_ft:
        for side, sign in (("L", -1), ("R", 1)):
            offset_in = mid_board_offset_L_in if side == "L" else mid_board_offset_R_in
            base_x = ft(xi_ft) + sign * (inch(pile_width_in / 2.0) + inch(mid_board_thick_in)) + inch(offset_in)
            base_y = ft(y_mid_ft) - inch(mid_board_len_in / 2.0)
            base_z = inch(beam_base_z_in)
            board = Part.makeBox(
                inch(mid_board_thick_in),
                inch(mid_board_len_in),
                inch(mid_board_depth_in)
            )
            mb = doc.addObject("Part::Feature", f"MidBoard_{int(xi_ft)}_{side}")
            mb.Shape = board
            mb.Placement.Base = App.Vector(base_x, base_y, base_z)
            if "label" not in mb.PropertiesList:
                mb.addProperty("App::PropertyString", "label")
            mb.label = mid_board_label
            if mid_board_label in catalog:
                row = catalog[mid_board_label]
                for prop in ("supplier", "sku", "url"):
                    val = row.get(prop)
                    if val:
                        if prop not in mb.PropertiesList:
                            mb.addProperty("App::PropertyString", prop)
                        mb.__setattr__(prop, val)
            if "cut_length_in" not in mb.PropertiesList:
                mb.addProperty("App::PropertyString", "cut_length_in")
            mb.cut_length_in = str(mid_board_len_in)
            midboard_objs.append(mb)

# Notch piles with beam geometry (boolean cut)
for pile in pile_objs:
    try:
        new_shape = pile.Shape
        for cutter in list(beam_objs) + list(midboard_objs):
            try:
                new_shape = new_shape.cut(cutter.Shape)
            except Exception:
                pass
        pile.Shape = new_shape
    except Exception:
        pass

# Grouping
lot_grp = doc.addObject("App::DocumentObjectGroup", "Lot")
lot_grp.addObject(lot_obj)
lot_grp.addObject(buildable_obj)
lot_grp.addObject(cross_obj)

piles_grp = doc.addObject("App::DocumentObjectGroup", "Piles")
for p in pile_objs:
    piles_grp.addObject(p)
beams_grp = doc.addObject("App::DocumentObjectGroup", "Beams")
for b in beam_objs:
    beams_grp.addObject(b)
block_grp = doc.addObject("App::DocumentObjectGroup", "Blocking")
for blk in blocking_objs:
    block_grp.addObject(blk)
mid_grp = doc.addObject("App::DocumentObjectGroup", "MidBoards")
# Ensure all midboards (L/R) are grouped even if created earlier in the doc.
mid_grp.Group = []
for obj in doc.Objects:
    try:
        if obj.Name.startswith("MidBoard_"):
            mid_grp.addObject(obj)
    except Exception:
        pass
sheathing_objs = []
second_sheathing_objs = []

# Hanger helper (axis=Y so rim face is at world Y; joist runs along X)
def make_hanger(name, rim_pos_in, joist, direction=1, axis="Y"):
    if lc is None:
        return None
    # Center hanger on joist along X; joist width is along Y
    j = joist
    center_x = (j.Placement.Base.x + (j.Shape.BoundBox.XLength / 2.0)) / 25.4  # inches
    center_y = (j.Placement.Base.y + (j.Shape.BoundBox.YLength / 2.0)) / 25.4  # inches
    axis = (axis or "Y").upper()
    if axis == "X":
        pos = rim_pos_in
        center = center_y
        axis_val = "X"
    else:
        pos = rim_pos_in
        center = center_x
        axis_val = "Y"
    return lc.make_hanger(
        doc,
        name,
        pos,
        center,
        joist_thick_in,
        hanger_thickness_in,
        hanger_height_in,
        hanger_seat_depth_in,
        hanger_label,
        direction=direction,
        axis=axis_val,
        color=hanger_color,
    )

def raise_hanger_to_joist(hanger_obj, base_z_mm):
    """Lift hanger to joist elevation (helpers build at Z=0)."""
    if hanger_obj is None:
        return
    pl = hanger_obj.Placement
    pl.Base.z = base_z_mm  # keep in mm (doc units)
    hanger_obj.Placement = pl

def run_macro_file(path):
    if not os.path.isfile(path):
        raise RuntimeError(f"Macro not found: {path}")
    env = {
        "__file__": path,
        "__name__": "__main__",
        "__builtins__": __builtins__,
        "App": App,
        "FreeCAD": App,
        "Part": Part,
        "os": os,
        "sys": sys,
        "math": math,
        "csv": csv,
    }
    with open(path, "r", encoding="utf-8") as f:
        code = f.read()
    exec(compile(code, path, "exec"), env, env)

def clone_group(template_group, new_name, x_off_ft, y_off_ft, z_base_mm, label_override=None):
    """Clone all children of template_group with offsets; return new group."""
    if not template_group:
        return None
    new_parts = []
    for obj in template_group.Group:
        new_obj = doc.addObject(obj.TypeId, f"{new_name}_{obj.Name}")
        new_obj.Shape = obj.Shape.copy()
        pl = obj.Placement.copy()
        pl.Base.x += inch(x_off_ft * 12.0)
        pl.Base.y += inch(y_off_ft * 12.0)
        pl.Base.z += z_base_mm
        new_obj.Placement = pl
        try:
            for prop in obj.PropertiesList:
                if prop in ("Label", "Placement", "Shape"):
                    continue
                val = getattr(obj, prop, None)
                if isinstance(val, str):
                    if prop not in new_obj.PropertiesList:
                        new_obj.addProperty("App::PropertyString", prop)
                    setattr(new_obj, prop, val)
        except Exception:
            pass
        try:
            new_obj.Label = obj.Label
            new_obj.ViewObject.ShapeColor = obj.ViewObject.ShapeColor
        except Exception:
            pass
        new_parts.append(new_obj)
    grp = doc.addObject("App::DocumentObjectGroup", new_name)
    grp.Label = label_override or new_name
    for p in new_parts:
        grp.addObject(p)
    return grp

def place_wall_instance(template_group, new_name, label, x_pos_ft, y_pos_ft, z_base_mm, rot):
    """Copy a wall template group and place it with rotation and offsets."""
    if not template_group:
        return None
    placed = doc.copyObject(template_group, True)
    try:
        doc.renameObject(placed.Name, new_name)
    except Exception:
        pass
    placed.Label = label
    for obj in placed.Group:
        pl = obj.Placement
        pl.Rotation = rot.multiply(pl.Rotation)
        pl.Base = rot.multVec(pl.Base)
        obj.Placement = pl
    # After rotation, align the minimum corner of the group bounding box to the requested anchor.
    bbox = None
    for obj in placed.Group:
        try:
            bb = obj.Shape.BoundBox
        except Exception:
            continue
        if bbox is None:
            bbox = App.BoundBox(bb)
        else:
            bbox.add(bb)
    if bbox:
        dx = ft(x_pos_ft) - bbox.XMin
        dy = ft(y_pos_ft) - bbox.YMin
        dz = z_base_mm - bbox.ZMin
        for obj in placed.Group:
            pl = obj.Placement
            pl.Base.x += dx
            pl.Base.y += dy
            pl.Base.z += dz
            obj.Placement = pl
    return placed

def cleanup_loose_wall_parts(doc_obj):
    """Remove any wall part primitives left unattached at root."""
    loose_prefixes = (
        "Plate_", "King_", "Jack_", "Header_", "Stud80_", "Header_Ply_", "Header_Cap_Plate",
        "Sliding_Door_", "Window_Wall_", "Stud_Wall_", "Wall_",
        "Short_bottom", "bottom_cap", "stud60",
    )
    loose_names = {
        "Plate_Bottom", "Plate_Top", "King_Left", "King_Right", "Jack_Left", "Jack_Right",
        "Header_2x12_A", "Header_2x12_B", "Header_Ply_0p5", "Header_Cap_Plate",
        "Short_bottom_X", "bottom_cap_90", "stud60_X",
    }
    for obj in list(doc_obj.Objects):
        try:
            if obj.isDerivedFrom("App::DocumentObjectGroup"):
                continue
        except Exception:
            pass
        # If object lives in no groups and matches wall part prefixes, remove it
        in_groups = getattr(obj, "InList", []) or []
        name_low = getattr(obj, "Name", "").lower()
        if in_groups:
            continue
        if obj.Name in loose_names or any(name_low.startswith(pref.lower()) for pref in loose_prefixes):
            try:
                doc_obj.removeObject(obj.Name)
            except Exception:
                pass

def build_stair_module(base_x_ft, base_y_ft, base_z_ft, target_z_ft, direction=1, axis="Y"):
    """Straight stair: 8 risers, 7 treads.
    direction: +1 builds in +axis, -1 in -axis. axis in {"Y","X"}.
    """
    grp = doc.addObject("App::DocumentObjectGroup", "Stair_Module")
    num_risers = 8
    num_treads = 7
    width_in = 48.0
    tread_depth_in = 11.25  # 2x12 nominal
    tread_thick_in = 1.5
    riser_thick_in = 0.75   # 1x8 nominal thickness
    riser_board_label = "1x8x96"
    # Use the actual rise for each step so treads sit directly on the riser top without gaps.
    rise_total_in = (target_z_ft - base_z_ft) * 12.0
    rise_in = rise_total_in / num_risers
    landing_depth_in = 96.0  # 8'
    landing_thick_in = sheathing_thick_in  # Advantech

    def add_box(name, dx_in, dy_in, dz_in, px_ft, py_ft, pz_ft, label):
        box = Part.makeBox(inch(dx_in), inch(dy_in), inch(dz_in))
        obj = doc.addObject("Part::Feature", name)
        obj.Shape = box
        obj.Placement.Base = App.Vector(ft(px_ft), ft(py_ft), ft(pz_ft))
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = label
        return obj

    # Build treads/risers
    offset_x_stair_ft = -((tread_depth_in - 2 * riser_thick_in) / 12.0) if axis == "Y" else 0.0
    for i in range(num_treads):
        z_step_ft = base_z_ft + (rise_in * i) / 12.0
        run_ft = (tread_depth_in * i) / 12.0
        riser_height_in = rise_in  # set riser height equal to actual rise for this flight
        if axis == "X":
            # Swap run to Y so Y increases with each step; X stays fixed
            x_step_ft = base_x_ft
            y_step_ft = base_y_ft + direction * run_ft
        else:
            x_step_ft = base_x_ft
            y_step_ft = base_y_ft + direction * run_ft
        x_step_ft += offset_x_stair_ft
        tread_run_ft = (riser_thick_in / 12.0)
        if axis == "X":
            tread_x_ft = x_step_ft
            tread_y_ft = y_step_ft + direction * tread_run_ft
        else:
            tread_x_ft = x_step_ft
            tread_y_ft = y_step_ft + direction * tread_run_ft
        tread_z_base_ft = z_step_ft + (riser_height_in / 12.0) - (tread_thick_in / 12.0)  # tread sits on top of riser
        tread = add_box(f"Stair_Tread_{i}", width_in, tread_depth_in, tread_thick_in, tread_x_ft, tread_y_ft, tread_z_base_ft, "2x12_stair_tread")
        riser = add_box(f"Stair_Riser_{i}", width_in, riser_thick_in, riser_height_in, x_step_ft, y_step_ft, z_step_ft, riser_board_label)
        grp.addObject(tread)
        grp.addObject(riser)
    # Top riser to align with landing
    top_riser_z_ft = base_z_ft + (rise_in * num_treads) / 12.0
    if axis == "X":
        top_x = base_x_ft
        top_y = base_y_ft + direction * (tread_depth_in * num_treads) / 12.0
    else:
        top_x = base_x_ft
        top_y = base_y_ft + direction * (tread_depth_in * num_treads) / 12.0
    top_riser = add_box("Stair_Riser_Top", width_in, riser_thick_in, rise_in, top_x, top_y, top_riser_z_ft, riser_board_label)
    grp.addObject(top_riser)

    return grp

# Upper-flight builder: uses stair rim left as reference and keeps boards fixed
def build_top_flight(assembly, second_sheath_top_ft, first_sheath_top_ft, tile_stack_ft, vpl_thick_ft):
    """Create upper flight risers/treads and add to assembly."""
    rim_left = doc.getObject("Stair_Rim_Left")
    bb_rim = rim_left.Shape.BoundBox if rim_left else None
    if bb_rim is None:
        return
    x_face_ft = bb_rim.XMin / ft(1.0)
    y_base_ft = bb_rim.YMin / ft(1.0)
    total_rise_ft = max(0.0, (second_sheath_top_ft + vpl_thick_ft) - (first_sheath_top_ft + tile_stack_ft))
    riser_height_ft = total_rise_ft / 16.0 if total_rise_ft > 0 else (7.5625 / 12.0)
    riser_height_in = riser_height_ft * 12.0
    riser_thick_ft = 0.75 / 12.0
    riser_width_ft = (48.0 - 2.75) / 12.0  # trim 2.25" wall + 0.5" drywall gap
    z_base_ft = (second_sheath_top_ft + vpl_thick_ft) - (riser_height_in / 12.0)

    # Riser 0 at second-floor level
    riser_top = doc.addObject("Part::Feature", "Stair_Riser_TopFlight_0")
    riser_top.Shape = Part.makeBox(ft(riser_width_ft), ft(riser_thick_ft), inch(riser_height_in))
    riser_top.Placement = App.Placement(
        App.Vector(ft(x_face_ft - riser_thick_ft + 0.25), ft(y_base_ft + 4.0 - (1.5/12.0)), ft(z_base_ft)),
        App.Rotation(App.Vector(0, 0, 1), 90),
    )
    riser_top.Label = "1x8_riser"
    assembly.addObject(riser_top)

    # Tread 0 under riser 0
    tread_depth_in = 11.25
    tread_thick_in = 1.5
    tread = doc.addObject("Part::Feature", "Stair_Tread_TopFlight_0")
    tread.Shape = Part.makeBox(ft(riser_width_ft), inch(tread_depth_in), inch(tread_thick_in))
    tread_z_base_ft = z_base_ft - (tread_thick_in / 12.0)
    tread.Placement = App.Placement(
        App.Vector(ft(x_face_ft - riser_thick_ft + 0.25 + (10.5/12.0)), ft(y_base_ft + 4.0 - (1.5/12.0)), ft(tread_z_base_ft)),
        App.Rotation(App.Vector(0, 0, 1), 90),
    )
    tread.Label = "2x12_stair_tread"
    assembly.addObject(tread)

    # Risers/treads 1..7 (tread up to 6; landing acts as final tread)
    run_ft = tread_depth_in / 12.0
    start_x = x_face_ft - riser_thick_ft + 0.25
    start_z = z_base_ft
    for i in range(1, 8):
        x_base_riser = start_x + run_ft * i
        y_base_riser = y_base_ft + 4.0 - (1.5/12.0)
        z_base_riser = start_z - (riser_height_in / 12.0) * i
        riser_i = doc.addObject("Part::Feature", f"Stair_Riser_TopFlight_{i}")
        riser_i.Shape = Part.makeBox(ft(riser_width_ft), ft(riser_thick_ft), inch(riser_height_in))
        riser_i.Placement = App.Placement(App.Vector(ft(x_base_riser), ft(y_base_riser), ft(z_base_riser)),
                                          App.Rotation(App.Vector(0, 0, 1), 90))
        riser_i.Label = "1x8_riser"
        assembly.addObject(riser_i)
        if i <= 6:
            tread_i = doc.addObject("Part::Feature", f"Stair_Tread_TopFlight_{i}")
            tread_i.Shape = Part.makeBox(ft(riser_width_ft), inch(tread_depth_in), inch(tread_thick_in))
            tread_z_base_ft = z_base_riser - (tread_thick_in / 12.0)
            tread_x_base_ft = x_base_riser + (10.5 / 12.0)
            tread_i.Placement = App.Placement(App.Vector(ft(tread_x_base_ft), ft(y_base_riser), ft(tread_z_base_ft)),
                                              App.Rotation(App.Vector(0, 0, 1), 90))
            tread_i.Label = "2x12_stair_tread"
            assembly.addObject(tread_i)
    try:
        count = len([o for o in assembly.Group if o.Name.startswith("Stair_Riser_TopFlight") or o.Name.startswith("Stair_Tread_TopFlight")])
        App.Console.PrintMessage(f"[stair_topflight] built {count} parts\n")
    except Exception:
        pass

def build_custom_wall(length_ft, height_in, name_prefix, stud_width_in=3.5):
    """Wall of arbitrary height (double top plates) running +Y. Default 2x4; override stud_width_in for 2x6, etc."""
    stud_thick_in = 1.5
    spacing_oc_in = 16.0
    plate_thick_in = 1.5
    plate_width_in = stud_width_in
    top_plates = 2
    plate_length_in = length_ft * 12.0
    stud_length_in = max(0.0, height_in - plate_thick_in * (1 + top_plates))
    nominal = 6 if stud_width_in > 4.0 else 4
    grp = doc.addObject("App::DocumentObjectGroup", name_prefix)
    def make_plate(name, z_base):
        box = Part.makeBox(inch(plate_width_in), inch(plate_length_in), inch(plate_thick_in))
        obj = doc.addObject("Part::Feature", name)
        obj.Shape = box
        obj.Placement.Base = App.Vector(0, 0, inch(z_base))
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = f"2x{nominal}_plate_custom"
        return obj
    def make_stud(name, y_base, z_base):
        box = Part.makeBox(inch(stud_width_in), inch(stud_thick_in), inch(stud_length_in))
        obj = doc.addObject("Part::Feature", name)
        obj.Shape = box
        obj.Placement.Base = App.Vector(0, inch(y_base), inch(z_base))
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = f"2x{nominal}x{stud_length_in/12.0:.3f}"
        return obj
    grp.addObject(make_plate(f"{name_prefix}_Plate_Bottom", 0.0))
    z_top_base = plate_thick_in + stud_length_in
    for i in range(top_plates):
        grp.addObject(make_plate(f"{name_prefix}_Plate_Top{i+1}", z_top_base + i * plate_thick_in))
    centers = []
    first_center = stud_thick_in / 2.0
    last_center = plate_length_in - (stud_thick_in / 2.0)
    c = first_center
    while c < last_center - 1e-6:
        centers.append(c)
        c += spacing_oc_in
    if not centers or centers[-1] < last_center - 1e-6:
        centers.append(last_center)
    for idx, center in enumerate(centers, start=1):
        y_base = center - (stud_thick_in / 2.0)
        grp.addObject(make_stud(f"{name_prefix}_Stud_{idx}", y_base, plate_thick_in))
    return grp

# Build stair with landing frame, sheathing, and support walls
def build_stair_assembly():
    """
    Place only the stair footprint rim box in house coordinates (no flights/landing yet).
    Box size: X = 16' - 3" (15.75'), Y = 8'.
    Left (inner) rim outer face aligns to the right outer face of
    Module2_Joists_2x12_16x8_Mid_Left_Rim_Right.
    """
    assembly = doc.addObject("App::DocumentObjectGroup", "Stair_Assembly")

    ref = doc.getObject("Module2_Joists_2x12_16x8_Mid_Left_Rim_Right")
    if not ref or not hasattr(ref, "Shape"):
        return assembly
    bb = ref.Shape.BoundBox
    x_face = bb.XMax  # align to this face
    y_base_ft = mid_base_y_ft
    width_x_ft = 16.0 - (3.0 / 12.0)  # 15.75'
    depth_y_ft = 8.0
    thickness_ft = joist_thick_in / 12.0
    z0_ft = second_base_z_ft

    # Left (inner) rim: outer face at x_face => base at x_face - thickness
    x_base_ft = (x_face / ft(1.0)) - thickness_ft
    debug_msg = f"[stair_rims_box] ref XMax={x_face/ft(1.0):.3f}ft base=({x_base_ft:.3f},{y_base_ft:.3f})ft box={width_x_ft:.3f}x{depth_y_ft:.3f}ft\n"
    App.Console.PrintMessage(debug_msg)

    # Left rim (runs Y) +1.5" in X
    left = Part.makeBox(inch(joist_thick_in), ft(depth_y_ft), inch(joist_depth_in))
    o_left = doc.addObject("Part::Feature", "Stair_Rim_Left")
    o_left.Shape = left
    o_left.Placement.Base = App.Vector(ft(x_base_ft + (1.5/12.0)), ft(y_base_ft), ft(z0_ft))
    o_left.Label = "Joist_2x12_Left_Rim"
    assembly.addObject(o_left)

    # Right (outer) rim (runs Y) +4.5" in X
    x_right_base_ft = x_base_ft + width_x_ft - thickness_ft
    right = Part.makeBox(inch(joist_thick_in), ft(depth_y_ft), inch(joist_depth_in))
    o_right = doc.addObject("Part::Feature", "Stair_Rim_Right")
    o_right.Shape = right
    o_right.Placement.Base = App.Vector(ft(x_right_base_ft + (4.5/12.0)), ft(y_base_ft), ft(z0_ft))
    o_right.Label = "Joist_2x12_Right_Rim"
    assembly.addObject(o_right)

    # Front rim (runs X) +3" in X
    front = Part.makeBox(ft(width_x_ft), inch(joist_thick_in), inch(joist_depth_in))
    o_front = doc.addObject("Part::Feature", "Stair_Rim_Front")
    o_front.Shape = front
    o_front.Placement.Base = App.Vector(ft(x_base_ft + (3.0/12.0)), ft(y_base_ft), ft(z0_ft))
    o_front.Label = "Joist_2x12_Front_Rim"
    assembly.addObject(o_front)

    # Back rim (runs X) +3" in X
    y_back_ft = y_base_ft + depth_y_ft - thickness_ft
    back = Part.makeBox(ft(width_x_ft), inch(joist_thick_in), inch(joist_depth_in))
    o_back = doc.addObject("Part::Feature", "Stair_Rim_Back")
    o_back.Shape = back
    o_back.Placement.Base = App.Vector(ft(x_base_ft + (3.0/12.0)), ft(y_back_ft), ft(z0_ft))
    o_back.Label = "Joist_2x12_Back_Rim"
    assembly.addObject(o_back)

    # First-floor interior wall under the front rim (12' long, 104.625" studs, dbl top plate), oriented along +X
    def build_wall_along_x(length_ft, height_in, name_prefix, stud_width_in=5.5):
        stud_thick_in = 1.5
        plate_thick_in = 1.5
        plate_width_in = stud_width_in
        spacing_oc_in = 16.0
        top_plates = 2
        plate_length_in = length_ft * 12.0
        stud_length_in = height_in - plate_thick_in * (1 + top_plates)
        grp = doc.addObject("App::DocumentObjectGroup", name_prefix)
        nominal = 6 if stud_width_in > 4.0 else 4
        def add_plate(label_suffix, z_base_in):
            box = Part.makeBox(inch(plate_length_in), inch(plate_width_in), inch(plate_thick_in))
            obj = doc.addObject("Part::Feature", f"{name_prefix}_{label_suffix}")
            obj.Shape = box
            obj.Placement.Base = App.Vector(0, 0, inch(z_base_in))
            obj.Label = f"2x{nominal}_plate_custom"
            grp.addObject(obj)
        add_plate("Plate_Bottom", 0.0)
        z_top_base = plate_thick_in + stud_length_in
        add_plate("Plate_Top1", z_top_base)
        add_plate("Plate_Top2", z_top_base + plate_thick_in)
        centers = []
        first_center = stud_thick_in / 2.0
        last_center = plate_length_in - (stud_thick_in / 2.0)
        c = first_center
        while c < last_center - 1e-6:
            centers.append(c)
            c += spacing_oc_in
        if not centers or centers[-1] < last_center - 1e-6:
            centers.append(last_center)
        for idx, center in enumerate(centers, start=1):
            x_base_in = center - (stud_thick_in / 2.0)
            stud_box = Part.makeBox(inch(stud_thick_in), inch(stud_width_in), inch(stud_length_in))
            obj = doc.addObject("Part::Feature", f"{name_prefix}_Stud_{idx}")
            obj.Shape = stud_box
            obj.Placement.Base = App.Vector(inch(x_base_in), 0, inch(plate_thick_in))
            obj.Label = f"2x{nominal}x{stud_length_in/12.0:.3f}"
            grp.addObject(obj)
        return grp

    wall_len_ft = 12.0
    # Target height: from first-floor sheathing top up to rim bottom
    first_sheath_top_ft = module_base_z_ft + (joist_depth_in + sheathing_thick_in) / 12.0
    second_sheath_top_ft = second_base_z_ft + (joist_depth_in + sheathing_thick_in) / 12.0
    wall_height_in = max(0.0, (z0_ft - first_sheath_top_ft) * 12.0)
    try:
        walls_root = doc.getObject("First_Floor_Interior_Walls")
        if walls_root is None:
            walls_root = doc.addObject("App::DocumentObjectGroup", "First_Floor_Interior_Walls")
    except Exception:
        walls_root = doc.addObject("App::DocumentObjectGroup", "First_Floor_Interior_Walls")

    # Front wall (shifted -4" in Y)
    wall_front = build_wall_along_x(wall_len_ft, wall_height_in, "Stair_Front_Wall", stud_width_in=5.5)
    base_front = App.Vector(ft(x_base_ft), ft(y_base_ft - (4.0/12.0)), ft(first_sheath_top_ft))
    for obj in wall_front.Group:
        pl = obj.Placement
        pl.Base = base_front + pl.Base
        obj.Placement = pl
    walls_root.addObject(wall_front)

    # Back wall (shifted near rim back edge; remove 1.5" nudge)
    wall_back = build_wall_along_x(wall_len_ft, wall_height_in, "Stair_Back_Wall", stud_width_in=5.5)
    y_back_ft_local = y_base_ft + depth_y_ft - thickness_ft
    base_back = App.Vector(ft(x_base_ft), ft(y_back_ft_local), ft(first_sheath_top_ft))
    for obj in wall_back.Group:
        pl = obj.Placement
        pl.Base = base_back + pl.Base
        obj.Placement = pl
    walls_root.addObject(wall_back)

    # Finished floor stacks
    tile_stack_ft = (0.5 + 0.125 + 0.375) / 12.0  # Hardie 1/2" + thinset 1/8" + tile 3/8"
    vpl_thick_ft = 0.26 / 12.0  # approx 6.5mm vinyl plank

    # Kicker board (2x4x8) tying the two 2x6 walls; runs along +Y at the rim reference X
    # Lay flat: 1.5" thickness vertical, 3.5" runs +Y, length trimmed to 8' - 3" (trim 1.5" each end)
    kicker_dx_ft = 8.0 - (3.0 / 12.0)
    kicker_dy_in = 3.5
    kicker_dz_in = 1.5
    kicker = doc.addObject("Part::Feature", "Stair_Kicker")
    kicker.Shape = Part.makeBox(ft(kicker_dx_ft), inch(kicker_dy_in), inch(kicker_dz_in))
    # Kicker sits on subfloor (not atop finish); riser 0 will absorb the finished-floor stack.
    kicker_shift_ft = 2.75 / 12.0
    base_vec = App.Vector(ft(x_base_ft + (1.5/12.0) + kicker_shift_ft), ft(y_base_ft + (1.5/12.0)), ft(first_sheath_top_ft))
    kicker.Placement = App.Placement(base_vec, App.Rotation(App.Vector(0, 0, 1), 90))
    kicker.Label = "2x4_kicker"
    assembly.addObject(kicker)

    # Place first riser: 48" wide, 0.75" thick, height = rise to second floor / 8
    try:
        bb_kick = kicker.Shape.BoundBox
    except Exception:
        bb_kick = None
    if bb_kick is not None:
        # Derive riser height from finished floor-to-finished floor assuming 16 risers total (8 per flight)
        total_rise_ft = max(0.0, (second_sheath_top_ft + vpl_thick_ft) - (first_sheath_top_ft + tile_stack_ft))
        riser_height_ft = total_rise_ft / 16.0 if total_rise_ft > 0 else (7.5625 / 12.0)
        riser_height_in = riser_height_ft * 12.0
        riser_height_first_ft = riser_height_ft + tile_stack_ft  # first rise spans subfloor -> finished floor
        riser_width_ft = (48.0 - 2.75) / 12.0  # trim 2.25" wall + 0.5" drywall gap
        riser_thick_ft = 0.75 / 12.0
        tread_depth_in = 11.25
        tread_thick_in = 1.5

        run_ft = tread_depth_in / 12.0  # horizontal run per step
        base_y = bb_kick.YMin / ft(1.0)
        lower_y_offset_ft = 0.5 / 12.0  # leave room for drywall
        base_x = (bb_kick.XMin / ft(1.0)) - riser_thick_ft + (0.75/12.0)
        for i in range(8):
            # Advance in +X each step to avoid stacking; Y stays with kicker
            x_base_riser = base_x + run_ft * i
            y_base_riser = base_y + lower_y_offset_ft
            if i == 0:
                riser_ht_ft = riser_height_first_ft
                z_base_riser = first_sheath_top_ft
            else:
                riser_ht_ft = riser_height_ft
                z_base_riser = first_sheath_top_ft + riser_height_first_ft + riser_height_ft * (i - 1)
            riser = doc.addObject("Part::Feature", f"Stair_Riser_{i}")
            riser.Shape = Part.makeBox(ft(riser_width_ft), ft(riser_thick_ft), inch(riser_ht_ft * 12.0))
            riser.Placement = App.Placement(App.Vector(ft(x_base_riser), ft(y_base_riser), ft(z_base_riser)),
                                            App.Rotation(App.Vector(0, 0, 1), 90))
            riser.Label = "1x8_riser"
            assembly.addObject(riser)
            if i < 7:
                tread = doc.addObject("Part::Feature", f"Stair_Tread_{i}")
                tread.Shape = Part.makeBox(ft(riser_width_ft), inch(tread_depth_in), inch(tread_thick_in))
                tread_z_base_ft = z_base_riser + riser_ht_ft - (tread_thick_in / 12.0)
                tread_x_base_ft = x_base_riser + riser_width_ft - (tread_depth_in / 12.0) - 2.0 + (.75/12.0)
                tread.Placement = App.Placement(App.Vector(ft(tread_x_base_ft), ft(y_base_riser), ft(tread_z_base_ft)),
                                                App.Rotation(App.Vector(0, 0, 1), 90))
                tread.Label = "2x12_stair_tread"
                assembly.addObject(tread)

        # Landing Advantech 3/4" panel, 4'x8', 8' runs in +Y; top flush with last riser top
        panel_thick_ft = 0.75 / 12.0
        panel_x_ft = 4.0
        panel_y_ft = 8.0 - (3.0 / 12.0)  # trim 3" off Y to account for rim/2x6 walls
        x_last = base_x + run_ft * 7
        y_last = base_y
        z_last = first_sheath_top_ft + riser_height_first_ft + riser_height_ft * 6
        panel_top_z = z_last + riser_height_ft
    panel = doc.addObject("Part::Feature", "Stair_Landing_Panel")
    panel.Shape = Part.makeBox(ft(panel_x_ft), ft(panel_y_ft), inch(0.75))
    panel.Placement.Base = App.Vector(ft(x_last), ft(y_last), ft(panel_top_z - panel_thick_ft))
    panel.Label = "3/4_advantech"
    assembly.addObject(panel)

    # Right-edge landing wall (2x4, 104 5/8" studs, double top plate) running along +Y at the landing's right edge
    try:
        walls_root = doc.getObject("First_Floor_Interior_Walls")
        if walls_root is None:
            walls_root = doc.addObject("App::DocumentObjectGroup", "First_Floor_Interior_Walls")
    except Exception:
        walls_root = doc.addObject("App::DocumentObjectGroup", "First_Floor_Interior_Walls")
    wall_len_ft = panel_y_ft
    stud_len_in = 104.625  # full stud length requested
    plate_thick_in = 1.5
    wall_height_in = stud_len_in + plate_thick_in * 3  # bottom + double top plates
    wall_right = build_custom_wall(wall_len_ft, wall_height_in, "Stair_Right_Wall", stud_width_in=3.5)
    wall_base = App.Vector(ft(x_last + panel_x_ft), ft(y_last), ft(first_sheath_top_ft))
    for obj in wall_right.Group:
        pl = obj.Placement
        pl.Base = wall_base + pl.Base
        obj.Placement = pl
    walls_root.addObject(wall_right)

    # Central wall between lower and upper flights (2x4, 104 5/8" studs, double top plate)
    try:
        stair_bb = assembly.Shape.BoundBox
        kicker_bb = doc.getObject("Stair_Kicker").Shape.BoundBox if doc.getObject("Stair_Kicker") else None
        panel_bb = doc.getObject("Stair_Landing_Panel").Shape.BoundBox if doc.getObject("Stair_Landing_Panel") else None
    except Exception:
        stair_bb = None
        kicker_bb = None
        panel_bb = None
    if stair_bb and kicker_bb and panel_bb:
        wall_len_ft_center = max(6.0, (panel_bb.XMin - kicker_bb.XMin) / ft(1.0))
        stud_len_in_center = 104.625
        wall_height_in_center = stud_len_in_center + plate_thick_in * 3  # bottom + double top plates
        wall_center = build_custom_wall(wall_len_ft_center, wall_height_in_center, "Stair_Center_Wall", stud_width_in=3.5)
        wall_width_ft = 3.5 / 12.0
        wall_x_base_ft = (panel_bb.XMin / ft(1.0)) - wall_len_ft_center
        wall_y_base_ft = (stair_bb.YMin + stair_bb.YMax) / (2 * ft(1.0)) - wall_width_ft / 2.0
        wall_base_vec = App.Vector(ft(wall_x_base_ft), ft(wall_y_base_ft), ft(first_sheath_top_ft))
        rot90 = App.Rotation(App.Vector(0, 0, 1), 90)
        for obj in wall_center.Group:
            old_pl = obj.Placement
            rel = old_pl.Base  # local offset from wall origin
            new_base = wall_base_vec + rot90.multVec(rel)
            obj.Placement = App.Placement(new_base, rot90.multiply(old_pl.Rotation))
        walls_root.addObject(wall_center)

    # Build the upper flight (riser/tread objects) so they survive cleanup and grouping
    build_top_flight(assembly, second_sheath_top_ft, first_sheath_top_ft, tile_stack_ft, vpl_thick_ft)

    return assembly

# Helper to clone a wall group upward by dz (used for second-floor walls)
def clone_wall_group(group, dz_ft, new_name):
    """Deep-clone a wall group (and subgroups) upward by dz_ft, preserving placements."""
    def clone_children(src_grp, dst_parent):
        for child in getattr(src_grp, "Group", []):
            if child.isDerivedFrom("App::DocumentObjectGroup"):
                sub_name = child.Name
                sub_label = child.Label
                if not sub_label.startswith("Second_Floor_"):
                    sub_label = f"Second_Floor_{sub_label}"
                sub = doc.addObject("App::DocumentObjectGroup", sub_name)
                sub.Label = sub_label
                dst_parent.addObject(sub)
                clone_children(child, sub)
            else:
                if not hasattr(child, "Placement"):
                    continue
                c = doc.copyObject(child, False)
                pl = c.Placement
                pl.Base = App.Vector(pl.Base.x, pl.Base.y, pl.Base.z + ft(dz_ft))
                c.Placement = pl
                lbl = getattr(c, "Label", getattr(c, "Name", ""))
                if not lbl.startswith("Second_Floor_"):
                    c.Label = f"Second_Floor_{lbl}"
                dst_parent.addObject(c)
    try:
        clone_grp = doc.addObject("App::DocumentObjectGroup", new_name)
        clone_children(group, clone_grp)
        if not getattr(clone_grp, "Group", []):
            App.Console.PrintError(f"[950Surf] Clone {new_name} empty (source {getattr(group,'Name',group)})\n")
            return None
        return clone_grp
    except Exception as e:
        App.Console.PrintError(f"[950Surf] Failed to clone {getattr(group,'Name',group)}: {e}\n")
        return None

# --- End build_stair_assembly ---
# 2x4 plate dimensions for top plates
cap_plate_thick_in = 1.5
cap_plate_width_in = 3.5
cap_plate_nominal_ft = 16.0
cap_overlap_ft = cap_plate_width_in / 12.0  # extend at corners to tie walls

def place_cap_for_group(group, name_prefix):
    """Lay cap plates along the major axis of a wall group using 16' segments."""
    try:
        objs = group.Group
    except Exception:
        return []
    bbox = None
    for obj in objs:
        try:
            bb = obj.Shape.BoundBox
        except Exception:
            continue
        bbox = App.BoundBox(bb) if bbox is None else bbox.add(bb) or bbox
    if bbox is None:
        return []
    along_x = bbox.XLength >= bbox.YLength
    run_len_ft = (bbox.XLength if along_x else bbox.YLength) / ft(1.0)
    run_len_ft += 2 * cap_overlap_ft
    start_x = bbox.XMin - (cap_overlap_ft * ft(1.0))
    start_y = bbox.YMin - (cap_overlap_ft * ft(1.0)) if not along_x else bbox.YMin
    z_base_mm = bbox.ZMax
    segs = []
    remaining = run_len_ft
    offset_ft = 0.0
    idx = 1
    while remaining > 1e-6:
        seg_ft = cap_plate_nominal_ft if remaining > cap_plate_nominal_ft else remaining
        if along_x:
            dx = ft(seg_ft)
            dy = inch(cap_plate_width_in)
            x0 = start_x + ft(offset_ft)
            y0 = start_y
        else:
            dx = inch(cap_plate_width_in)
            dy = ft(seg_ft)
            x0 = start_x
            y0 = start_y + ft(offset_ft)
        obj = doc.addObject("Part::Feature", f"{name_prefix}_Cap_{idx}")
        obj.Shape = Part.makeBox(dx, dy, inch(cap_plate_thick_in))
        obj.Placement.Base = App.Vector(x0, y0, z_base_mm)
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = "2x4_cap_plate"
        segs.append(obj)
        remaining -= seg_ft
        offset_ft += seg_ft
        idx += 1
    return segs

def place_front_back_caps(group, name_prefix):
    """Front/Back caps: two 16' boards, first shifted +3.5\" in X."""
    try:
        objs = group.Group
    except Exception:
        return []
    bbox = None
    for obj in objs:
        try:
            bb = obj.Shape.BoundBox
        except Exception:
            continue
        bbox = App.BoundBox(bb) if bbox is None else bbox.add(bb) or bbox
    if bbox is None:
        return []
    z_base_mm = bbox.ZMax
    x0 = bbox.XMin + inch(3.5)  # shift +3.5" in X for cap 1 start
    y0 = bbox.YMin
    caps = []
    cap_lengths_ft = {1: 16.0, 2: 16.0 - (7.0 / 12.0)}  # cap2 trimmed by 7"
    for idx in (1, 2):
        seg_len_ft = cap_lengths_ft.get(idx, 16.0)
        obj = doc.addObject("Part::Feature", f"{name_prefix}_Cap_{idx}")
        obj.Shape = Part.makeBox(ft(seg_len_ft), inch(cap_plate_width_in), inch(cap_plate_thick_in))
        start_x = x0 if idx == 1 else x0 + ft(16.0)  # cap2 starts after full 16'
        obj.Placement.Base = App.Vector(start_x, y0, z_base_mm)
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = "2x4_cap_plate"
        caps.append(obj)
    return caps

def build_plain_stud_wall(length_ft, name_prefix, group_label):
    """Build a plain 2x4 stud wall of arbitrary length (runs +Y) and group it."""
    spacing_oc_in = 16.0
    stud_thick_in = 1.5
    stud_width_in = 3.5
    stud_length_in = 104.625
    plate_thick_in = 1.5
    plate_width_in = 3.5
    plate_length_in = length_ft * 12.0
    group = doc.addObject("App::DocumentObjectGroup", group_label)
    def make_plate(name, z_base):
        box = Part.makeBox(inch(plate_width_in), inch(plate_length_in), inch(plate_thick_in))
        obj = doc.addObject("Part::Feature", name)
        obj.Shape = box
        obj.Placement.Base = App.Vector(0, 0, inch(z_base))
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = "2x4_plate_custom"
        return obj
    def make_stud(name, x_base, y_base, z_base):
        box = Part.makeBox(inch(stud_width_in), inch(stud_thick_in), inch(stud_length_in))
        obj = doc.addObject("Part::Feature", name)
        obj.Shape = box
        obj.Placement.Base = App.Vector(inch(x_base), inch(y_base), inch(z_base))
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = "2x4x104.625"
        return obj
    objs = []
    objs.append(make_plate(f"{name_prefix}_Plate_Bottom", 0.0))
    objs.append(make_plate(f"{name_prefix}_Plate_Top", plate_thick_in + stud_length_in))
    centers = []
    first_center = stud_thick_in / 2.0
    last_center = plate_length_in - (stud_thick_in / 2.0)
    c = first_center
    while c < last_center - 1e-6:
        centers.append(c)
        c += spacing_oc_in
    if not centers or centers[-1] < last_center - 1e-6:
        centers.append(last_center)
    for idx, center in enumerate(centers, start=1):
        y_base = center - (stud_thick_in / 2.0)
        objs.append(make_stud(f"{name_prefix}_Stud_{idx}", 0.0, y_base, plate_thick_in))
    for o in objs:
        group.addObject(o)
    return group

# Front row positions (shift L/R out 4' each; add an 8'x16' center)
right_shift_ft = 4.0 + (3.0 / 12.0)  # 4' plus 3" to clear rim overlap
front_right_x_ft = module_left_x_ft + right_shift_ft
front_left_x_ft = module_left_x_ft - module_x_ft - 4.0
front_center_x_ft = front_left_x_ft + module_x_ft  # 8' wide center module starts here
mid_right_x_ft = front_right_x_ft  # same x positions for mid/back rows
mid_left_x_ft = front_left_x_ft
back_right_x_ft = front_right_x_ft
back_left_x_ft = front_left_x_ft

# Joist module 16x16 (2x12 @ 16" OC), right module
module_grp = doc.addObject("App::DocumentObjectGroup", "Module_Joists_2x12_16x16_Front_Right")
joist_depth_in = beam_depth_in
joist_thick_in = beam_thick_in
base_x_mod = ft(front_right_x_ft)
base_y_mod = ft(module_front_y_ft)
base_z_mod = ft(module_base_z_ft)
joist_base_x = base_x_mod + inch(1.5)  # shift joists/rims 1.5" in X
module_length_in = module_x_ft * 12.0
module_width_in = module_y_ft * 12.0
idx = 0
first_spacing_ft = module_first_spacing_in / 12.0
joist_spacing_ft = module_joist_spacing_in / 12.0
end_gap_ft = first_spacing_ft  # keep same gap at back
current_y_ft = module_front_y_ft + first_spacing_ft
joist_objs_FR = []
while (current_y_ft + joist_thick_in / 12.0) <= (module_front_y_ft + module_y_ft - end_gap_ft + 1e-6):
    joist = Part.makeBox(
        inch(module_length_in),
        inch(joist_thick_in),
        inch(joist_depth_in)
    )
    obj = doc.addObject("Part::Feature", f"Module_Joist_{idx}")
    obj.Shape = joist
    obj.Placement.Base = App.Vector(
        joist_base_x,
        ft(current_y_ft),
        base_z_mod
    )
    if "label" not in obj.PropertiesList:
        obj.addProperty("App::PropertyString", "label")
    obj.label = module_joist_label
    if module_joist_label in catalog:
        row = catalog[module_joist_label]
        for prop in ("supplier", "sku", "url"):
            val = row.get(prop)
            if val:
                if prop not in obj.PropertiesList:
                    obj.addProperty("App::PropertyString", prop)
                obj.__setattr__(prop, val)
    module_grp.addObject(obj)
    joist_objs_FR.append(obj)
    idx += 1
    current_y_ft += joist_spacing_ft

# Rim joists (front/back), running along X
for suffix, y_off in (("Front", 0.0), ("Back", module_y_ft - joist_thick_in / 12.0)):
    rim = Part.makeBox(
        inch(module_length_in),
        inch(joist_thick_in),
        inch(joist_depth_in)
    )
    rim_obj = doc.addObject("Part::Feature", f"Module_Rim_{suffix}")
    rim_obj.Shape = rim
    rim_obj.Placement.Base = App.Vector(
        joist_base_x,
        base_y_mod + ft(y_off),
        base_z_mod
    )
    if "label" not in rim_obj.PropertiesList:
        rim_obj.addProperty("App::PropertyString", "label")
    rim_obj.label = module_joist_label
    if module_joist_label in catalog:
        row = catalog[module_joist_label]
        for prop in ("supplier", "sku", "url"):
            val = row.get(prop)
        if val:
            if prop not in rim_obj.PropertiesList:
                rim_obj.addProperty("App::PropertyString", prop)
            rim_obj.__setattr__(prop, val)
    module_grp.addObject(rim_obj)

# Rim joists (left/right), running along Y
for suffix, x_off, extra in (
    ("Left", 0.0, 0.0),
    ("Right", module_x_ft - joist_thick_in / 12.0, inch(3.0)),  # shift right rim +3"
):
    rim = Part.makeBox(
        inch(joist_thick_in),
        inch(module_width_in),
        inch(joist_depth_in)
    )
    rim_obj = doc.addObject("Part::Feature", f"Module_Rim_{suffix}")
    rim_obj.Shape = rim
    rim_obj.Placement.Base = App.Vector(
        base_x_mod + ft(x_off) + extra,
        base_y_mod,
        base_z_mod
    )
    if "label" not in rim_obj.PropertiesList:
        rim_obj.addProperty("App::PropertyString", "label")
    rim_obj.label = module_joist_label
    if module_joist_label in catalog:
        row = catalog[module_joist_label]
        for prop in ("supplier", "sku", "url"):
            val = row.get(prop)
        if val:
            if prop not in rim_obj.PropertiesList:
                rim_obj.addProperty("App::PropertyString", prop)
            rim_obj.__setattr__(prop, val)
    module_grp.addObject(rim_obj)

# Hangers for front-right (skip rim joists). Convert mm bases to inches for helper.
hanger_grp_FR = doc.addObject("App::DocumentObjectGroup", "Joist_Hardware_FR")
base_y_mod_in = base_y_mod / 25.4
left_rim_face_in = (base_x_mod + inch(joist_thick_in)) / 25.4
right_rim_face_in = (base_x_mod + ft(module_x_ft - joist_thick_in / 12.0) + inch(3.0)) / 25.4
for idx, j in enumerate(joist_objs_FR):
    h1 = make_hanger(f"Hanger_FR_L_{idx}", left_rim_face_in, j, direction=1, axis="X")
    h2 = make_hanger(f"Hanger_FR_R_{idx}", right_rim_face_in, j, direction=-1, axis="X")
    if h1:
        raise_hanger_to_joist(h1, base_z_mod)
        hanger_grp_FR.addObject(h1)
    if h2:
        # shift right hangers +1.5" in Y
        pl = h2.Placement
        pl.Base.y += inch(1.5)
        h2.Placement = pl
        raise_hanger_to_joist(h2, base_z_mod)
        # Flip right hangers 180 deg so flanges face inward
        rot = h2.Placement.Rotation
        h2.Placement.Rotation = App.Rotation(App.Vector(0, 0, 1), 180).multiply(rot)
        hanger_grp_FR.addObject(h2)
module_grp.addObject(hanger_grp_FR)

# Foundation roll-up group
foundation_grp = doc.addObject("App::DocumentObjectGroup", "Foundation")
for sub in (piles_grp, beams_grp, block_grp, mid_grp):
    foundation_grp.addObject(sub)

# Mirror joist module to front-left (across lot centerline)
module_grp_L = doc.addObject("App::DocumentObjectGroup", "Module_Joists_2x12_16x16_Front_Left")
module_L_x_offset = -inch(3.0)  # shift entire left module -3" in X
base_x_mod_L = ft(front_left_x_ft) + module_L_x_offset
joist_base_x_L = base_x_mod_L + inch(1.5)
idx = 0
current_y_ft = module_front_y_ft + first_spacing_ft
joist_objs_FL = []
while (current_y_ft + joist_thick_in / 12.0) <= (module_front_y_ft + module_y_ft - end_gap_ft + 1e-6):
    joist = Part.makeBox(
        inch(module_length_in),
        inch(joist_thick_in),
        inch(joist_depth_in)
    )
    obj = doc.addObject("Part::Feature", f"ModuleL_Joist_{idx}")
    obj.Shape = joist
    obj.Placement.Base = App.Vector(
        joist_base_x_L,
        ft(current_y_ft),
        base_z_mod
    )
    if "label" not in obj.PropertiesList:
        obj.addProperty("App::PropertyString", "label")
    obj.label = module_joist_label
    if module_joist_label in catalog:
        row = catalog[module_joist_label]
        for prop in ("supplier", "sku", "url"):
            val = row.get(prop)
            if val:
                if prop not in obj.PropertiesList:
                    obj.addProperty("App::PropertyString", prop)
                obj.__setattr__(prop, val)
    module_grp_L.addObject(obj)
    joist_objs_FL.append(obj)
    idx += 1
    current_y_ft += joist_spacing_ft

for suffix, y_off in (("Front", 0.0), ("Back", module_y_ft - joist_thick_in / 12.0)):
    rim = Part.makeBox(
        inch(module_length_in),
        inch(joist_thick_in),
        inch(joist_depth_in)
    )
    rim_obj = doc.addObject("Part::Feature", f"ModuleL_Rim_{suffix}")
    rim_obj.Shape = rim
    rim_obj.Placement.Base = App.Vector(
        joist_base_x_L,
        base_y_mod + ft(y_off),
        base_z_mod
    )
    if "label" not in rim_obj.PropertiesList:
        rim_obj.addProperty("App::PropertyString", "label")
    rim_obj.label = module_joist_label
    if module_joist_label in catalog:
        row = catalog[module_joist_label]
        for prop in ("supplier", "sku", "url"):
            val = row.get(prop)
        if val:
            if prop not in rim_obj.PropertiesList:
                rim_obj.addProperty("App::PropertyString", prop)
            rim_obj.__setattr__(prop, val)
    module_grp_L.addObject(rim_obj)

for suffix, x_off, extra in (
    ("Left", 0.0, 0.0),
    ("Right", module_x_ft - joist_thick_in / 12.0, inch(3.0)),
):
    rim = Part.makeBox(
        inch(joist_thick_in),
        inch(module_width_in),
        inch(joist_depth_in)
    )
    rim_obj = doc.addObject("Part::Feature", f"ModuleL_Rim_{suffix}")
    rim_obj.Shape = rim
    rim_obj.Placement.Base = App.Vector(
        base_x_mod_L + ft(x_off) + extra,
        base_y_mod,
        base_z_mod
    )
    if "label" not in rim_obj.PropertiesList:
        rim_obj.addProperty("App::PropertyString", "label")
    rim_obj.label = module_joist_label
    if module_joist_label in catalog:
        row = catalog[module_joist_label]
        for prop in ("supplier", "sku", "url"):
            val = row.get(prop)
            if val:
                if prop not in rim_obj.PropertiesList:
                    rim_obj.addProperty("App::PropertyString", prop)
                rim_obj.__setattr__(prop, val)
    module_grp_L.addObject(rim_obj)

# Hangers for front-left (skip rim joists)
hanger_grp_FL = doc.addObject("App::DocumentObjectGroup", "Joist_Hardware_FL")
base_y_mod_in_L = base_y_mod / 25.4
left_rim_face_in_L = (base_x_mod_L + inch(joist_thick_in)) / 25.4
right_rim_face_in_L = (base_x_mod_L + ft(module_x_ft - joist_thick_in / 12.0) + inch(3.0)) / 25.4
for idx, j in enumerate(joist_objs_FL):
    h1 = make_hanger(f"Hanger_FL_L_{idx}", left_rim_face_in_L, j, direction=1, axis="X")
    h2 = make_hanger(f"Hanger_FL_R_{idx}", right_rim_face_in_L, j, direction=-1, axis="X")
    if h1:
        raise_hanger_to_joist(h1, base_z_mod)
        hanger_grp_FL.addObject(h1)
    if h2:
        # shift right hangers +1.5" in Y
        pl = h2.Placement
        pl.Base.y += inch(1.5)
        h2.Placement = pl
        raise_hanger_to_joist(h2, base_z_mod)
        rot = h2.Placement.Rotation
        h2.Placement.Rotation = App.Rotation(App.Vector(0, 0, 1), 180).multiply(rot)
        hanger_grp_FL.addObject(h2)
module_grp_L.addObject(hanger_grp_FL)

# Helper to tile 4x8 sheathing panels (staggered rows)
def tile_sheathing(base_x_ft, base_y_ft, len_ft, width_ft, prefix, x_extra_in=0.0, z_ft=None, panel_list=None):
    """
    Tile 4x8 sheathing panels in staggered rows.
    Stagger pattern: start at bottom-left, run full 8' along Y until a cut piece is needed;
    next column starts with that cut height, then full sheets, etc.
    - z_ft: optional top-of-joist elevation in feet. Defaults to first-floor joist top.
    - panel_list: list to append panels into (defaults to first-floor sheathing list).
    """
    if panel_list is None:
        panel_list = sheathing_objs
    z_base_mm = ft(z_ft) if z_ft is not None else (base_z_mod + inch(joist_depth_in))
    base_x_ft_adj = base_x_ft + (x_extra_in / 12.0)
    panel_long_ft = 8.0  # along Y (perpendicular to joists)
    panel_short_ft = 4.0  # along X
    total_cols = int(math.ceil(len_ft / panel_short_ft))
    for c in range(total_cols):
        x0_ft = base_x_ft_adj + c * panel_short_ft
        x_size_ft = min(panel_short_ft, (base_x_ft_adj + len_ft) - x0_ft)
        # Brick/road stagger: every other column starts with a 4' starter
        start_piece_ft = panel_long_ft / 2.0 if (c % 2 == 1) else 0.0
        y_ft = base_y_ft
        segment_idx = 0
        if start_piece_ft > 1e-6:
            y_size_ft = min(start_piece_ft, width_ft)
            panel = Part.makeBox(
                inch(x_size_ft * 12.0),
                inch(y_size_ft * 12.0),
                inch(sheathing_thick_in)
            )
            pnl = doc.addObject("Part::Feature", f"{prefix}_Sheathing_{c}_{segment_idx}")
            pnl.Shape = panel
            pnl.Placement.Base = App.Vector(ft(x0_ft), ft(y_ft), z_base_mm)
            if "label" not in pnl.PropertiesList:
                pnl.addProperty("App::PropertyString", "label")
            pnl.label = sheathing_label
            if sheathing_label in catalog:
                rowcat = catalog[sheathing_label]
                for prop in ("supplier", "sku", "url"):
                    val = rowcat.get(prop)
                    if val:
                        if prop not in pnl.PropertiesList:
                            pnl.addProperty("App::PropertyString", prop)
                        pnl.__setattr__(prop, val)
            panel_list.append(pnl)
            segment_idx += 1
            y_ft += y_size_ft
        last_piece_ft = 0.0
        while y_ft < base_y_ft + width_ft - 1e-6:
            remaining_y = (base_y_ft + width_ft) - y_ft
            y_size_ft = min(panel_long_ft, remaining_y)
            last_piece_ft = y_size_ft
            panel = Part.makeBox(
                inch(x_size_ft * 12.0),
                inch(y_size_ft * 12.0),
                inch(sheathing_thick_in)
            )
            pnl = doc.addObject("Part::Feature", f"{prefix}_Sheathing_{c}_{segment_idx}")
            pnl.Shape = panel
            pnl.Placement.Base = App.Vector(ft(x0_ft), ft(y_ft), z_base_mm)
            if "label" not in pnl.PropertiesList:
                pnl.addProperty("App::PropertyString", "label")
            pnl.label = sheathing_label
            if sheathing_label in catalog:
                rowcat = catalog[sheathing_label]
                for prop in ("supplier", "sku", "url"):
                    val = rowcat.get(prop)
                    if val:
                        if prop not in pnl.PropertiesList:
                            pnl.addProperty("App::PropertyString", prop)
                        pnl.__setattr__(prop, val)
            panel_list.append(pnl)
            segment_idx += 1
            y_ft += y_size_ft

# Middle row (8' deep) modules
mid_base_y_ft = module_front_y_ft + module_y_ft  # start after front 16'

def build_row(group_prefix, base_x_ft, base_y_ft, len_ft, width_ft, is_left=False, x_extra_in=0.0):
    grp = doc.addObject("App::DocumentObjectGroup", group_prefix)
    base_x_local = ft(base_x_ft) + inch(x_extra_in)
    base_y_local = ft(base_y_ft)
    joist_base_x_local = base_x_local + inch(1.5)
    module_length_in_local = len_ft * 12.0
    module_width_in_local = width_ft * 12.0
    idx_local = 0
    cy_ft_local = base_y_ft + first_spacing_ft
    joist_objs_local = []
    while (cy_ft_local + joist_thick_in / 12.0) <= (base_y_ft + width_ft - end_gap_ft + 1e-6):
        joist = Part.makeBox(
            inch(module_length_in_local),
            inch(joist_thick_in),
            inch(joist_depth_in)
        )
        obj = doc.addObject("Part::Feature", f"{group_prefix}_Joist_{idx_local}")
        obj.Shape = joist
        obj.Placement.Base = App.Vector(
            joist_base_x_local,
            ft(cy_ft_local),
            base_z_mod
        )
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = module_joist_label
        if module_joist_label in catalog:
            row = catalog[module_joist_label]
            for prop in ("supplier", "sku", "url"):
                val = row.get(prop)
                if val:
                    if prop not in obj.PropertiesList:
                        obj.addProperty("App::PropertyString", prop)
                    obj.__setattr__(prop, val)
        grp.addObject(obj)
        joist_objs_local.append(obj)
        idx_local += 1
        cy_ft_local += joist_spacing_ft

    for suffix, y_off in (("Front", 0.0), ("Back", width_ft - joist_thick_in / 12.0)):
        rim = Part.makeBox(
            inch(module_length_in_local),
            inch(joist_thick_in),
            inch(joist_depth_in)
        )
        rim_obj = doc.addObject("Part::Feature", f"{group_prefix}_Rim_{suffix}")
        rim_obj.Shape = rim
        rim_obj.Placement.Base = App.Vector(
            joist_base_x_local,
            base_y_local + ft(y_off),
            base_z_mod
        )
        if "label" not in rim_obj.PropertiesList:
            rim_obj.addProperty("App::PropertyString", "label")
        rim_obj.label = module_joist_label
        if module_joist_label in catalog:
            row = catalog[module_joist_label]
            for prop in ("supplier", "sku", "url"):
                val = row.get(prop)
                if val:
                    if prop not in rim_obj.PropertiesList:
                        rim_obj.addProperty("App::PropertyString", prop)
                    rim_obj.__setattr__(prop, val)
        grp.addObject(rim_obj)

    # Hangers for this module (skip first/last joist)
    hanger_grp_local = doc.addObject("App::DocumentObjectGroup", f"{group_prefix}_Hardware")
    base_y_local_in = base_y_local / 25.4
    left_rim_face_in = (base_x_local + inch(joist_thick_in)) / 25.4
    right_rim_face_in = (base_x_local + ft(len_ft - joist_thick_in / 12.0) + inch(3.0)) / 25.4
    for idx_local, j in enumerate(joist_objs_local):
        h1 = make_hanger(f"{group_prefix}_H_L_{idx_local}", left_rim_face_in, j, direction=1, axis="X")
        h2 = make_hanger(f"{group_prefix}_H_R_{idx_local}", right_rim_face_in, j, direction=-1, axis="X")
        if h1:
            raise_hanger_to_joist(h1, base_z_mod)
            hanger_grp_local.addObject(h1)
        if h2:
            # shift right hangers +1.5" in Y for all non-FR modules
            pl = h2.Placement
            pl.Base.y += inch(1.5)
            h2.Placement = pl
            raise_hanger_to_joist(h2, base_z_mod)
            rot = h2.Placement.Rotation
            h2.Placement.Rotation = App.Rotation(App.Vector(0, 0, 1), 180).multiply(rot)
            hanger_grp_local.addObject(h2)
    grp.addObject(hanger_grp_local)

    for suffix, x_off, extra in (
        ("Left", 0.0, 0.0),
        ("Right", len_ft - joist_thick_in / 12.0, inch(3.0)),
    ):
        rim = Part.makeBox(
            inch(joist_thick_in),
            inch(module_width_in_local),
            inch(joist_depth_in)
        )
        rim_obj = doc.addObject("Part::Feature", f"{group_prefix}_Rim_{suffix}")
        rim_obj.Shape = rim
        rim_obj.Placement.Base = App.Vector(
            base_x_local + ft(x_off) + extra,
            base_y_local,
            base_z_mod
        )
        if "label" not in rim_obj.PropertiesList:
            rim_obj.addProperty("App::PropertyString", "label")
        rim_obj.label = module_joist_label
        if module_joist_label in catalog:
            row = catalog[module_joist_label]
            for prop in ("supplier", "sku", "url"):
                val = row.get(prop)
                if val:
                    if prop not in rim_obj.PropertiesList:
                        rim_obj.addProperty("App::PropertyString", prop)
                    rim_obj.__setattr__(prop, val)
        grp.addObject(rim_obj)

    # Sheathing is tiled globally after all modules are placed.

def build_row_at(group_prefix, base_x_ft, base_y_ft, len_ft, width_ft, z_ft, is_left=False, x_extra_in=0.0):
    """Same as build_row but allows overriding the base Z in feet."""
    z_mm = ft(z_ft)
    grp = doc.addObject("App::DocumentObjectGroup", group_prefix)
    base_x_local = ft(base_x_ft) + inch(x_extra_in)
    base_y_local = ft(base_y_ft)
    joist_base_x_local = base_x_local + inch(1.5)
    module_length_in_local = len_ft * 12.0
    module_width_in_local = width_ft * 12.0
    idx_local = 0
    cy_ft_local = base_y_ft + first_spacing_ft
    joist_objs_local = []
    while (cy_ft_local + joist_thick_in / 12.0) <= (base_y_ft + width_ft - end_gap_ft + 1e-6):
        joist = Part.makeBox(
            inch(module_length_in_local),
            inch(joist_thick_in),
            inch(joist_depth_in)
        )
        obj = doc.addObject("Part::Feature", f"{group_prefix}_Joist_{idx_local}")
        obj.Shape = joist
        obj.Placement.Base = App.Vector(
            joist_base_x_local,
            ft(cy_ft_local),
            z_mm
        )
        if "label" not in obj.PropertiesList:
            obj.addProperty("App::PropertyString", "label")
        obj.label = module_joist_label
        if module_joist_label in catalog:
            row = catalog[module_joist_label]
            for prop in ("supplier", "sku", "url"):
                val = row.get(prop)
                if val:
                    if prop not in obj.PropertiesList:
                        obj.addProperty("App::PropertyString", prop)
                    obj.__setattr__(prop, val)
        grp.addObject(obj)
        joist_objs_local.append(obj)
        idx_local += 1
        cy_ft_local += joist_spacing_ft

    for suffix, y_off in (("Front", 0.0), ("Back", width_ft - joist_thick_in / 12.0)):
        rim = Part.makeBox(
            inch(module_length_in_local),
            inch(joist_thick_in),
            inch(joist_depth_in)
        )
        rim_obj = doc.addObject("Part::Feature", f"{group_prefix}_Rim_{suffix}")
        rim_obj.Shape = rim
        rim_obj.Placement.Base = App.Vector(
            joist_base_x_local,
            base_y_local + ft(y_off),
            z_mm
        )
        if "label" not in rim_obj.PropertiesList:
            rim_obj.addProperty("App::PropertyString", "label")
        rim_obj.label = module_joist_label
        if module_joist_label in catalog:
            row = catalog[module_joist_label]
            for prop in ("supplier", "sku", "url"):
                val = row.get(prop)
                if val:
                    if prop not in rim_obj.PropertiesList:
                        rim_obj.addProperty("App::PropertyString", prop)
                    rim_obj.__setattr__(prop, val)
        grp.addObject(rim_obj)

    hanger_grp_local = doc.addObject("App::DocumentObjectGroup", f"{group_prefix}_Hardware")
    left_rim_face_in = (base_x_local + inch(joist_thick_in)) / 25.4
    right_rim_face_in = (base_x_local + ft(len_ft - joist_thick_in / 12.0) + inch(3.0)) / 25.4
    for idx_local, j in enumerate(joist_objs_local):
        h1 = make_hanger(f"{group_prefix}_H_L_{idx_local}", left_rim_face_in, j, direction=1, axis="X")
        h2 = make_hanger(f"{group_prefix}_H_R_{idx_local}", right_rim_face_in, j, direction=-1, axis="X")
        if h1:
            raise_hanger_to_joist(h1, z_mm)
            hanger_grp_local.addObject(h1)
        if h2:
            pl = h2.Placement
            pl.Base.y += inch(1.5)
            h2.Placement = pl
            raise_hanger_to_joist(h2, z_mm)
            rot = h2.Placement.Rotation
            h2.Placement.Rotation = App.Rotation(App.Vector(0, 0, 1), 180).multiply(rot)
            hanger_grp_local.addObject(h2)
    grp.addObject(hanger_grp_local)

    for suffix, x_off, extra in (
        ("Left", 0.0, 0.0),
        ("Right", len_ft - joist_thick_in / 12.0, inch(3.0)),
    ):
        rim = Part.makeBox(
            inch(joist_thick_in),
            inch(module_width_in_local),
            inch(joist_depth_in)
        )
        rim_obj = doc.addObject("Part::Feature", f"{group_prefix}_Rim_{suffix}")
        rim_obj.Shape = rim
        rim_obj.Placement.Base = App.Vector(
            base_x_local + ft(x_off) + extra,
            base_y_local,
            z_mm
        )
        if "label" not in rim_obj.PropertiesList:
            rim_obj.addProperty("App::PropertyString", "label")
        rim_obj.label = module_joist_label
        if module_joist_label in catalog:
            row = catalog[module_joist_label]
            for prop in ("supplier", "sku", "url"):
                val = row.get(prop)
                if val:
                    if prop not in rim_obj.PropertiesList:
                        rim_obj.addProperty("App::PropertyString", prop)
                    rim_obj.__setattr__(prop, val)
        grp.addObject(rim_obj)

# Front center module (8x16) between left/right fronts
build_row("Module_Joists_2x12_8x16_Front_Center", front_center_x_ft, module_front_y_ft, 8.0, 16.0, is_left=False, x_extra_in=0.0)

# Middle modules
build_row("Module_Joists_2x12_16x8_Mid_Right", mid_right_x_ft, mid_base_y_ft, 16.0, 8.0, is_left=False, x_extra_in=0.0)
build_row("Module_Joists_2x12_16x8_Mid_Left", mid_left_x_ft, mid_base_y_ft, 16.0, 8.0, is_left=True, x_extra_in=-3.0)
build_row("Module_Joists_2x12_8x8_Mid_Center", front_center_x_ft, mid_base_y_ft, 8.0, 8.0, is_left=False, x_extra_in=0.0)

# Back row modules (16x16)
back_base_y_ft = module_front_y_ft + module_y_ft + 8.0
build_row("Module_Joists_2x12_16x16_Back_Right", back_right_x_ft, back_base_y_ft, 16.0, 16.0, is_left=False, x_extra_in=0.0)
build_row("Module_Joists_2x12_16x16_Back_Left", back_left_x_ft, back_base_y_ft, 16.0, 16.0, is_left=True, x_extra_in=-3.0)
build_row("Module_Joists_2x12_8x16_Back_Center", front_center_x_ft, back_base_y_ft, 8.0, 16.0, is_left=False, x_extra_in=0.0)

# Global sheathing: tile 4x8 panels across the center 32' (decking will cover the 4' overhangs)
center_x_ft = lot_x_ft / 2.0
footprint_x0_ft = center_x_ft - 16.0
footprint_x1_ft = center_x_ft + 16.0
footprint_len_ft = 32.0
footprint_y0_ft = module_front_y_ft
footprint_width_ft = module_y_ft + 8.0 + 16.0  # 16(front)+8(mid)+16(back)
tile_sheathing(footprint_x0_ft, footprint_y0_ft, footprint_len_ft, footprint_width_ft, "Floor_Sheathing", x_extra_in=0.0)
# HardieBacker underlayment (1/2" thick, 3x5 nominal) staggered to avoid lining up with subfloor seams
def tile_backer(base_x_ft, base_y_ft, len_ft, width_ft, prefix, z_ft, panel_len_ft=5.0, panel_w_ft=3.0, stagger=True, objs=None):
    objs = objs if objs is not None else []
    y = base_y_ft
    row = 0
    y_limit = base_y_ft + width_ft
    while y < y_limit - 1e-6:
        x_start = base_x_ft + ((panel_len_ft / 2.0) if (stagger and row % 2 == 1) else 0.0)
        x_limit = base_x_ft + len_ft
        x = max(x_start, base_x_ft)
        row_h = min(panel_w_ft, y_limit - y)
        while x < x_limit - 1e-6:
            seg_len = min(panel_len_ft, x_limit - x)
            name = f"{prefix}_{len(objs)}"
            plate = doc.addObject("Part::Feature", name)
            plate.Shape = Part.makeBox(ft(seg_len), ft(row_h), inch(0.5))
            plate.Placement.Base = App.Vector(ft(x), ft(y), ft(z_ft))
            plate.Label = "HardieBacker_1-2in_3x5"
            objs.append(plate)
            x += panel_len_ft
        y += panel_w_ft
        row += 1
    return objs

backer_objs = []
backer_z_ft = module_base_z_ft + (joist_depth_in + sheathing_thick_in) / 12.0  # sits atop subfloor; tile/thinset would sit above this
backer_objs = tile_backer(
    footprint_x0_ft,
    footprint_y0_ft,
    footprint_len_ft,
    footprint_width_ft,
    "Floor_HardieBacker",
    backer_z_ft,
)
if backer_objs:
    backer_group = doc.addObject("App::DocumentObjectGroup", "Floor_HardieBacker")
    backer_group.Label = "First_Floor_Floor_HardieBacker"
    for o in backer_objs:
        backer_group.addObject(o)

# Large-format wood-look tile (8x48 nominal, 3/8" thick) with 1/8" grout joints, half-staggered
def tile_planks(base_x_ft, base_y_ft, len_ft, width_ft, prefix, z_ft, plank_len_ft=4.0, plank_w_ft=8.0/12.0, joint_in=0.125, stagger=True, objs=None, thick_in=0.375):
    objs = objs if objs is not None else []
    joint_ft = joint_in / 12.0
    y = base_y_ft
    row = 0
    y_limit = base_y_ft + width_ft
    while y < y_limit - 1e-6:
        x_start = base_x_ft + ((plank_len_ft / 2.0) if (stagger and row % 2 == 1) else 0.0)
        x_limit = base_x_ft + len_ft
        x = max(x_start, base_x_ft)
        row_h = min(plank_w_ft, y_limit - y)
        while x < x_limit - 1e-6:
            seg_len = min(plank_len_ft, x_limit - x)
            name = f"{prefix}_{len(objs)}"
            plank = doc.addObject("Part::Feature", name)
            plank.Shape = Part.makeBox(ft(seg_len), ft(row_h), inch(thick_in))
            plank.Placement.Base = App.Vector(ft(x), ft(y), ft(z_ft))
            plank.Label = "Tile_WoodLook_8x48"
            objs.append(plank)
            x += plank_len_ft + joint_ft
        y += plank_w_ft + joint_ft
        row += 1
    return objs

tile_objs = []
tile_thinset_in = 0.125  # mortar bed estimate
tile_z_ft = backer_z_ft + (0.5 / 12.0) + (tile_thinset_in / 12.0)
tile_objs = tile_planks(
    footprint_x0_ft,
    footprint_y0_ft,
    footprint_len_ft,
    footprint_width_ft,
    "Floor_Tile",
    tile_z_ft,
)
if tile_objs:
    tile_group = doc.addObject("App::DocumentObjectGroup", "Floor_Tile")
    tile_group.Label = "First_Floor_Floor_Tile"
    for o in tile_objs:
        tile_group.addObject(o)

# Floor joists roll-up group
floor_grp = doc.addObject("App::DocumentObjectGroup", "Floor_Joists")
floor_grp.Label = "First_Floor_Floor_Joists"
for name in (
    "Module_Joists_2x12_16x16_Front_Right",
    "Module_Joists_2x12_16x16_Front_Left",
    "Module_Joists_2x12_8x16_Front_Center",
    "Module_Joists_2x12_16x8_Mid_Right",
    "Module_Joists_2x12_16x8_Mid_Left",
    "Module_Joists_2x12_8x8_Mid_Center",
    "Module_Joists_2x12_16x16_Back_Right",
    "Module_Joists_2x12_16x16_Back_Left",
    "Module_Joists_2x12_8x16_Back_Center",
):
    obj = doc.getObject(name)
    if obj:
        floor_grp.addObject(obj)

sheathing_grp = doc.addObject("App::DocumentObjectGroup", "Sheathing")
sheathing_grp.Label = "First_Floor_Sheathing"
for s in sheathing_objs:
    sheathing_grp.addObject(s)

# Front wall modules (two windows outside, two sliding doors center)
wall_base_z_mm = base_z_mod + inch(joist_depth_in + sheathing_thick_in)
macro_window = os.path.join(lumber_dir, "Window_Wall_Double_3x5.FCMacro")
macro_sliding = os.path.join(lumber_dir, "Sliding_Door_72x80.FCMacro")
# Cleanup any prior template instances so we don't accumulate stray parts
for obj in list(doc.Objects):
    lbl = getattr(obj, "Label", "")
    nm = getattr(obj, "Name", "")
    if lbl in ("Window_Wall_Double_3x5", "Sliding_Door_72x80") or nm.startswith(("Window_Wall_Double_3x5", "Sliding_Door_72x80")):
        try:
            doc.removeObject(obj.Name)
        except Exception:
            pass
run_macro_file(macro_window)
run_macro_file(macro_sliding)
window_template = doc.getObject("Window_Wall_Double_3x5")
sliding_template = doc.getObject("Sliding_Door_72x80")
rot90 = App.Rotation(App.Vector(0, 0, 1), 90)

# Front wall instances
front_wall_grp = doc.addObject("App::DocumentObjectGroup", "First_Floor_Front_Walls")
module_seq_front = [
    ("Front_Window_Left", window_template, front_left_x_ft, module_front_y_ft, 4.0, 0.0),
    ("Front_Sliding_1", sliding_template, front_left_x_ft + 8.0 + 4.0, module_front_y_ft, 0.0, 0.0),
    ("Front_Sliding_2", sliding_template, front_left_x_ft + 16.0, module_front_y_ft, 4.0, 0.0),
    ("Front_Window_Right", window_template, front_left_x_ft + 24.0, module_front_y_ft, 4.0, 0.0),
]
for name, tmpl, x_pos_ft, y_pos_ft, dx_ft, dy_ft in module_seq_front:
    placed = place_wall_instance(
        tmpl,
        name,
        name,
        x_pos_ft + dx_ft,
        y_pos_ft + dy_ft,
        wall_base_z_mm,
        rot90,
    )
    if placed:
        front_wall_grp.addObject(placed)

# Back wall instances (duplicate layout, shifted to rear of footprint)
back_wall_y_ft = module_front_y_ft + footprint_width_ft
back_wall_grp = doc.addObject("App::DocumentObjectGroup", "First_Floor_Back_Walls")
back_wall_dy_ft = -(3.5 / 12.0)  # shift back wall toward front by 3.5"
module_seq_back = [
    ("Back_Window_Left", window_template, front_left_x_ft, back_wall_y_ft, 4.0, back_wall_dy_ft),
    ("Back_Sliding_1", sliding_template, front_left_x_ft + 8.0 + 4.0, back_wall_y_ft, 0.0, back_wall_dy_ft),
    ("Back_Sliding_2", sliding_template, front_left_x_ft + 16.0, back_wall_y_ft, 4.0, back_wall_dy_ft),
    ("Back_Window_Right", window_template, front_left_x_ft + 24.0, back_wall_y_ft, 4.0, back_wall_dy_ft),
]
for name, tmpl, x_pos_ft, y_pos_ft, dx_ft, dy_ft in module_seq_back:
    placed = place_wall_instance(
        tmpl,
        name,
        name,
        x_pos_ft + dx_ft,
        y_pos_ft + dy_ft,
        wall_base_z_mm,
        rot90,
    )
    if placed:
        back_wall_grp.addObject(placed)

# Left wall instances: two 16' segments and one 8'-7" infill
def place_plain_wall(length_ft, name_prefix, x_pos_ft, y_pos_ft, z_base_mm, dy_ft=0.0):
    grp = build_plain_stud_wall(length_ft, name_prefix, name_prefix)
    # align bbox min to (x,y,z)
    bbox = None
    for obj in grp.Group:
        try:
            bb = obj.Shape.BoundBox
        except Exception:
            continue
        if bbox is None:
            bbox = App.BoundBox(bb)
        else:
            bbox.add(bb)
    if bbox:
        dx = ft(x_pos_ft) - bbox.XMin
        dy = ft(y_pos_ft + dy_ft) - bbox.YMin
        dz = z_base_mm - bbox.ZMin
        for obj in grp.Group:
            pl = obj.Placement
            pl.Base.x += dx
            pl.Base.y += dy
            pl.Base.z += dz
            obj.Placement = pl
    return grp

left_wall_grp = doc.addObject("App::DocumentObjectGroup", "First_Floor_Left_Walls")
left_wall_x_ft = front_left_x_ft + 4.0  # shift 4' in +X
left_y0_ft = module_front_y_ft + (3.5 / 12.0)  # shift 3.5" in +Y
left_len_front_ft = 16.0
left_len_mid_ft = 7.0 + (5.0 / 12.0)  # 7'-5"
left_len_back_ft = 16.0

seg1 = place_plain_wall(left_len_front_ft, "Left_Wall_Front", left_wall_x_ft, left_y0_ft, wall_base_z_mm)
seg2 = place_plain_wall(left_len_mid_ft, "Left_Wall_Mid", left_wall_x_ft, left_y0_ft + left_len_front_ft, wall_base_z_mm)
seg3 = place_plain_wall(left_len_back_ft, "Left_Wall_Back", left_wall_x_ft, left_y0_ft + left_len_front_ft + left_len_mid_ft, wall_base_z_mm)
for seg in (seg1, seg2, seg3):
    if seg:
        left_wall_grp.addObject(seg)

# Right wall instances (mirror approach): two 16' segments and one 7'-5" infill
right_wall_grp = doc.addObject("App::DocumentObjectGroup", "First_Floor_Right_Walls")
right_wall_x_ft = front_right_x_ft + (module_x_ft - 4.0) - (7.0 / 12.0) + (0.5 / 12.0)  # shift +0.5" in X
right_y0_ft = left_y0_ft  # same Y start with 3.5" forward shift
right_len_front_ft = 16.0
right_len_mid_ft = left_len_mid_ft  # 7'-5"
right_len_back_ft = 16.0

rseg1 = place_plain_wall(right_len_front_ft, "Right_Wall_Front", right_wall_x_ft, right_y0_ft, wall_base_z_mm)
rseg2 = place_plain_wall(right_len_mid_ft, "Right_Wall_Mid", right_wall_x_ft, right_y0_ft + right_len_front_ft, wall_base_z_mm)
rseg3 = place_plain_wall(right_len_back_ft, "Right_Wall_Back", right_wall_x_ft, right_y0_ft + right_len_front_ft + right_len_mid_ft, wall_base_z_mm)
for seg in (rseg1, rseg2, rseg3):
    if seg:
        right_wall_grp.addObject(seg)

# Cap plates over all first-floor walls
top_plate_grp = doc.addObject("App::DocumentObjectGroup", "First_Floor_Top_Plates")
for grp in (front_wall_grp, back_wall_grp):
    caps = place_front_back_caps(grp, grp.Name)
    for c in caps:
        top_plate_grp.addObject(c)
for grp in (left_wall_grp, right_wall_grp):
    caps = place_cap_for_group(grp, grp.Name)
    for c in caps:
        try:
            pl = c.Placement
            pl.Base.x += inch(3.5)
            c.Placement = pl
        except Exception:
            pass
        top_plate_grp.addObject(c)

# ------------------------------------------------------------
# Grouping / tree cleanup
# ------------------------------------------------------------
def ensure_group(doc, label):
    grp = doc.getObject(label)
    if grp is None:
        grp = doc.addObject("App::DocumentObjectGroup", label)
    return grp

def floor_from_obj(obj):
    lbl = getattr(obj, "Label", "")
    nm = getattr(obj, "Name", "")
    text = lbl or nm
    txt_lower = text.lower()
    # Explicit second-floor markers
    if text.startswith("Second_Floor_") or text.startswith("Joists_2x12_") and "_SF_" in text:
        return "second"
    if text.startswith("Second_") or text.startswith("Sheathing_SF_") or text.startswith("Second_Sheathing_"):
        return "second"
    # Explicit first-floor markers
    if text.startswith("First_Floor_"):
        return "first"
    if text.startswith("Module_Joists_") or text.startswith("ModuleL_") or text.startswith("Joist_Hardware_"):
        return "first"
    if text.startswith(("Front_", "Back_", "Left_", "Right_")) and "_Sliding" in text or "_Window" in text:
        return "first"
    if "hardiebacker" in txt_lower or "tile_woodlook" in txt_lower:
        return "first"
    if text.startswith("Joist_2x12_") or text.startswith("Hanger_"):
        return "first"
    if text.startswith("Stair_") or text.startswith("1x8_riser") or text.startswith("2x12_stair_tread") or text.startswith("3/4_advantech") or text.startswith("2x4_kicker"):
        return "first"
    # Default to first unless clearly second
    return "first"

# Top-level groups
lot_group = doc.getObject("Lot")
foundation_group = doc.getObject("Foundation")
first_floor = ensure_group(doc, "First_Floor")
second_floor = ensure_group(doc, "Second_Floor")

# Desired subgroups
ff_joists = ensure_group(doc, "First_Floor_Joists")
ff_flooring = ensure_group(doc, "First_Floor_Flooring")
ff_walls = ensure_group(doc, "First_Floor_Walls")
ff_stairs = ensure_group(doc, "First_Floor_Stairs")
sf_joists = ensure_group(doc, "Second_Floor_Joists_Group")
sf_walls = ensure_group(doc, "Second_Floor_Walls_Group")
sf_flooring = ensure_group(doc, "Second_Floor_Flooring")

# Helper to move safely
def move_to_group(obj, grp):
    try:
        doc.moveObjectToGroup(obj, grp)
    except Exception:
        pass

# Classifiers for subgroups
def is_first_joist(lbl):
    return lbl.startswith(("First_Floor_Module_Joists_", "ModuleL_", "Joist_Hardware_", "Module_Joists_", "Joist_2x12_", "Module_Rim_", "ModuleL_Rim_", "Hanger_"))

def is_first_flooring(lbl, lower_lbl):
    return "hardiebacker" in lower_lbl or "tile_woodlook" in lower_lbl or lbl.startswith(("First_Floor_Floor_HardieBacker", "First_Floor_Floor_Tile"))

def is_first_wall(lbl):
    return "Wall" in lbl or lbl.startswith(("First_Floor_Top_Plates", "Front_", "Back_", "Left_", "Right_")) or any(x in lbl for x in ("Plate", "Stud", "Header", "Cap", "Jack", "King", "Sliding", "Window"))

def is_first_stair(lbl, lower_lbl):
    return lbl.startswith("Stair_") or lbl.startswith(("1x8_riser", "2x12_stair_tread", "2x4_kicker", "3/4_advantech")) or "stair" in lower_lbl

def is_second_joist(lbl):
    return lbl.startswith(("Joists_2x12_")) or lbl.startswith("Second_Floor_Joists")

def is_second_flooring(lbl):
    return lbl.startswith(("Sheathing_SF_", "Second_Sheathing_", "Second_Floor_Sheathing", "Second_Floor_Flooring"))

def is_second_wall(lbl):
    return lbl.startswith(("Second_Floor_", "Front_", "Back_", "Left_", "Right_"))

# First move everything to floor groups
for obj in list(doc.Objects):
    if obj in (lot_group, foundation_group, first_floor, second_floor, ff_joists, ff_flooring, ff_walls, ff_stairs, sf_joists, sf_walls, sf_flooring):
        continue
    lbl = getattr(obj, "Label", "")
    nm = getattr(obj, "Name", "")
    floor = floor_from_obj(obj)
    target_floor_grp = first_floor if floor == "first" else second_floor
    if obj.getParentGroup() != target_floor_grp:
        move_to_group(obj, target_floor_grp)

# Now, within each floor, move into subgroups
for obj in list(first_floor.Group):
    lbl = getattr(obj, "Label", "")
    lower_lbl = lbl.lower()
    if is_first_joist(lbl):
        move_to_group(obj, ff_joists)
    elif is_first_flooring(lbl, lower_lbl):
        move_to_group(obj, ff_flooring)
    elif is_first_stair(lbl, lower_lbl):
        move_to_group(obj, ff_stairs)
    elif is_first_wall(lbl):
        move_to_group(obj, ff_walls)

for obj in list(second_floor.Group):
    lbl = getattr(obj, "Label", "")
    if is_second_joist(lbl):
        move_to_group(obj, sf_joists)
    elif is_second_flooring(lbl):
        move_to_group(obj, sf_flooring)
    elif is_second_wall(lbl):
        move_to_group(obj, sf_walls)

# Clean up template groups to avoid duplicates in tree
for tmpl in (window_template, sliding_template):
    try:
        doc.removeObject(tmpl.Name)
    except Exception:
        pass
# Final cleanup: remove any leftover top-level template pieces by name/label
for obj in list(doc.Objects):
    lbl = getattr(obj, "Label", "")
    nm = getattr(obj, "Name", "")
    if lbl in ("Window_Wall_Double_3x5", "Sliding_Door_72x80") or nm.startswith(("Window_Wall_Double_3x5", "Sliding_Door_72x80")):
        try:
            doc.removeObject(obj.Name)
        except Exception:
            pass
# Remove any stray ungrouped wall parts (plates/studs/headers)
cleanup_loose_wall_parts(doc)

# Second story joists (6 modules: front/mid/back, left/right only)
wall_height_ft = (1.5 + 104.625 + 1.5 + 1.5) / 12.0  # plates + stud + cap
second_base_z_ft = module_base_z_ft + (joist_depth_in + sheathing_thick_in) / 12.0 + wall_height_ft

second_x_inset_ft = 4.0
right_extra_inset_ft = 3.5 / 12.0  # additional inward move for right-side second-story modules
inset_adjust_ft = 0.5 / 12.0  # move each side outward by 0.5"
len_trim_ft = 3.0 / 12.0  # shorten second-story joists by 3"

sec_front_right_x_ft = front_right_x_ft - (second_x_inset_ft - inset_adjust_ft) - right_extra_inset_ft
sec_front_left_x_ft = front_left_x_ft + (second_x_inset_ft - inset_adjust_ft) + (3.5 / 12.0)
sec_mid_left_x_ft = mid_left_x_ft + (second_x_inset_ft - inset_adjust_ft) + (3.5 / 12.0)
sec_back_right_x_ft = back_right_x_ft - (second_x_inset_ft - inset_adjust_ft) - right_extra_inset_ft
sec_back_left_x_ft = back_left_x_ft + (second_x_inset_ft - inset_adjust_ft) + (3.5 / 12.0)
sec_len_ft = 16.0 - len_trim_ft
sec_sheath_len_ft = 16.0  # keep sheathing full-length to the rim
sec_z_top_ft = second_base_z_ft + (joist_depth_in / 12.0)

build_row_at(
    "Joists_2x12_16x16_SF_Front_Right",
    sec_front_right_x_ft,
    module_front_y_ft,
    sec_len_ft,
    16.0,
    second_base_z_ft,
    is_left=False,
    x_extra_in=0.0,
)
build_row_at(
    "Joists_2x12_16x16_SF_Front_Left",
    sec_front_left_x_ft,
    module_front_y_ft,
    sec_len_ft,
    16.0,
    second_base_z_ft,
    is_left=True,
    x_extra_in=-3.0,
)

build_row_at(
    "Joists_2x12_16x8_SF_Mid_Left",
    sec_mid_left_x_ft,
    mid_base_y_ft,
    sec_len_ft,
    8.0,
    second_base_z_ft,
    is_left=True,
    x_extra_in=-3.0,
)

build_row_at(
    "Joists_2x12_16x16_SF_Back_Right",
    sec_back_right_x_ft,
    back_base_y_ft,
    sec_len_ft,
    16.0,
    second_base_z_ft,
    is_left=False,
    x_extra_in=0.0,
)
build_row_at(
    "Joists_2x12_16x16_SF_Back_Left",
    sec_back_left_x_ft,
    back_base_y_ft,
    sec_len_ft,
    16.0,
    second_base_z_ft,
    is_left=True,
    x_extra_in=-3.0,
)

second_floor_grp = doc.addObject("App::DocumentObjectGroup", "Second_Floor_Joists")
for name in (
    "Joists_2x12_16x16_SF_Front_Right",
    "Joists_2x12_16x16_SF_Front_Left",
    "Joists_2x12_16x8_SF_Mid_Left",
    "Joists_2x12_16x16_SF_Back_Right",
    "Joists_2x12_16x16_SF_Back_Left",
):
    obj = doc.getObject(name)
    if obj:
        second_floor_grp.addObject(obj)

# Second-floor sheathing: tile over each second-story module footprint (no mid-right to leave stair opening)
tile_sheathing(sec_front_left_x_ft, module_front_y_ft, sec_sheath_len_ft, 16.0, "Sheathing_SF_Front_Left", x_extra_in=-3.0, z_ft=sec_z_top_ft, panel_list=second_sheathing_objs)
tile_sheathing(sec_front_right_x_ft, module_front_y_ft, sec_sheath_len_ft, 16.0, "Sheathing_SF_Front_Right", x_extra_in=0.0, z_ft=sec_z_top_ft, panel_list=second_sheathing_objs)
tile_sheathing(sec_mid_left_x_ft, mid_base_y_ft, sec_sheath_len_ft, 8.0, "Sheathing_SF_Mid_Left", x_extra_in=-3.0, z_ft=sec_z_top_ft, panel_list=second_sheathing_objs)
tile_sheathing(sec_back_left_x_ft, back_base_y_ft, sec_sheath_len_ft, 16.0, "Sheathing_SF_Back_Left", x_extra_in=-3.0, z_ft=sec_z_top_ft, panel_list=second_sheathing_objs)
tile_sheathing(sec_back_right_x_ft, back_base_y_ft, sec_sheath_len_ft, 16.0, "Sheathing_SF_Back_Right", x_extra_in=0.0, z_ft=sec_z_top_ft, panel_list=second_sheathing_objs)

second_sheathing_grp = doc.addObject("App::DocumentObjectGroup", "Second_Floor_Sheathing")
for s in second_sheathing_objs:
    second_sheathing_grp.addObject(s)

# Clone first-floor walls up to the second floor (bottom plates sit on second-floor sheathing)
first_floor_sheath_top_ft = module_base_z_ft + (joist_depth_in + sheathing_thick_in) / 12.0
dz_second_walls_ft = sec_z_top_ft - first_floor_sheath_top_ft
sec_wall_root = doc.addObject("App::DocumentObjectGroup", "Second_Floor_Walls")
wall_clone_map = [
    ("First_Floor_Front_Walls", "Second_Floor_Front_Walls"),
    ("First_Floor_Back_Walls", "Second_Floor_Back_Walls"),
    ("First_Floor_Left_Walls", "Second_Floor_Left_Walls"),
    ("First_Floor_Right_Walls", "Second_Floor_Right_Walls"),
]
for src_name, dst_name in wall_clone_map:
    src_grp = doc.getObject(src_name)
    if src_grp:
        clone = clone_wall_group(src_grp, dz_second_walls_ft, dst_name)
        if clone:
            sec_wall_root.addObject(clone)

# Stair assembly in mid-right opening
stair_asm = build_stair_assembly()
if stair_asm:
    pass

doc.recompute()

# Optional BOM export
try:
    bom_macro = os.path.join(macro_dir, "export_bom_beach.FCMacro")
    if os.path.isfile(bom_macro):
        env = {
            "__file__": bom_macro,
            "__name__": "__main__",
            "__builtins__": __builtins__,
            "App": App,
            "FreeCAD": App,
            "Part": Part,
            "os": os,
            "csv": csv,
        }
        with open(bom_macro, "r", encoding="utf-8") as f:
            code = f.read()
        exec(compile(code, bom_macro, "exec"), env, env)
except Exception as e:
    App.Console.PrintError(f"[950Surf] Failed to export BOM: {e}\n")

# Optional save
save_path = os.environ.get("LUMBER_SAVE_FCSTD")

# Re-group top-level objects for clarity and predictable tree
def ensure_group(name):
    g = doc.getObject(name)
    if g is None or not g.isDerivedFrom("App::DocumentObjectGroup"):
        try:
            g = doc.addObject("App::DocumentObjectGroup", name)
        except Exception:
            g = None
    return g

# Normalize floor group labels
for nm in ("Floor_HardieBacker", "Floor_Tile", "Floor_Joists", "Sheathing"):
    obj = doc.getObject(nm)
    if obj:
        lbl = getattr(obj, "Label", nm)
        if not lbl.startswith("First_Floor_"):
            obj.Label = f"First_Floor_{lbl}"

def is_second(obj):
    lbl = getattr(obj, "Label", getattr(obj, "Name", ""))
    name = getattr(obj, "Name", "")
    if name in ("Lot", "Foundation"):
        return False
    if lbl.startswith("Second_Floor_") or name.startswith("Second_Floor_"):
        return True
    if lbl.startswith(("Joists_2x12_16x16_SF", "Joists_2x12_16x8_SF", "Sheathing_SF_")):
        return True
    if name.startswith("Module2_Joists_2x12_"):
        return True
    return False

def is_first(obj):
    lbl = getattr(obj, "Label", getattr(obj, "Name", ""))
    name = getattr(obj, "Name", "")
    if name in ("Lot", "Foundation"):
        return False
    if is_second(obj):
        return False
    if lbl.startswith("First_Floor_"):
        return True
    if lbl.startswith(("Module_Joists_2x12_", "ModuleL_", "Joist_Hardware_", "Stair_")):
        return True
    if lbl.startswith(("Front_", "Back_", "Left_", "Right_")):
        return True
    if "HardieBacker" in lbl or "Tile" in lbl:
        return True
    return False

first_root = ensure_group("First_Floor")
second_root = ensure_group("Second_Floor")

for obj in list(doc.Objects):
    if obj in (first_root, second_root):
        continue
    if is_second(obj):
        if second_root:
            try:
                second_root.addObject(obj)
            except Exception:
                pass
        continue
    if is_first(obj) and first_root:
        try:
            # Prefix labels for clarity
            lbl = getattr(obj, "Label", getattr(obj, "Name", ""))
            if not lbl.startswith("First_Floor_"):
                obj.Label = f"First_Floor_{lbl}"
            first_root.addObject(obj)
        except Exception:
            pass

# Structured subgroups
def ensure_child_group(parent, name):
    if parent is None:
        return None
    g = doc.getObject(name)
    if g is None:
        try:
            g = doc.addObject("App::DocumentObjectGroup", name)
        except Exception:
            g = None
    if g and g not in getattr(parent, "Group", []):
        parent.addObject(g)
    return g

ff_joists = ensure_child_group(first_root, "First_Floor_Joists")
ff_flooring = ensure_child_group(first_root, "First_Floor_Flooring")
ff_walls = ensure_child_group(first_root, "First_Floor_Walls")
ff_stairs = ensure_child_group(first_root, "First_Floor_Stairs")

sf_joists = ensure_child_group(second_root, "Second_Floor_Joists_Group")
sf_walls = ensure_child_group(second_root, "Second_Floor_Walls_Group")
sf_flooring = ensure_child_group(second_root, "Second_Floor_Flooring")

def move(obj, subgroup):
    if subgroup is None:
        return
    try:
        if obj not in subgroup.Group:
            subgroup.addObject(obj)
    except Exception:
        pass

for obj in list(doc.Objects):
    lbl = getattr(obj, "Label", getattr(obj, "Name", ""))
    name = getattr(obj, "Name", "")
    # Second floor sub-groups first so they never get pushed into First_Floor buckets
    if is_second(obj):
        if lbl.startswith("Second_Floor_Joists") or lbl.startswith("Second_Floor_Sheathing") or lbl.startswith("Joists_2x12_16x16_SF") or lbl.startswith("Joists_2x12_16x8_SF"):
            move(obj, sf_joists)
        if (lbl.startswith("Second_Floor_") and "Wall" in lbl) or lbl.endswith(("001", "003", "004")):
            move(obj, sf_walls)
        if lbl.startswith("Second_Floor_Floor_") or lbl.startswith("Sheathing_SF_"):
            move(obj, sf_flooring)
        continue

    if is_first(obj):
        if lbl.startswith("First_Floor_Joists") or lbl.startswith("First_Floor_Sheathing") or lbl.startswith("First_Floor_Module_Joists_") or lbl.startswith("Joist_Hardware_") or (lbl.startswith("Module_Joists_2x12_") and "SF" not in lbl) or lbl.startswith("ModuleL_"):
            move(obj, ff_joists)
        if lbl.startswith("First_Floor_Floor_HardieBacker") or lbl.startswith("First_Floor_Floor_Tile"):
            move(obj, ff_flooring)
        if (lbl.startswith("First_Floor_") and "Wall" in lbl) or lbl.startswith("First_Floor_Top_Plates") or ("Cap" in lbl and lbl.startswith("First_Floor_")):
            move(obj, ff_walls)
        if lbl.startswith("First_Floor_Stair_") or lbl.startswith("Stair_"):
            move(obj, ff_stairs)

# Log grouping summary for quick CLI checks
try:
    groups = [o.Label for o in doc.Objects if o.isDerivedFrom("App::DocumentObjectGroup")]
    App.Console.PrintMessage(f"[950Surf] Top-level groups: {groups}\n")
    if first_root:
        kids = [getattr(o, "Label", o.Name) for o in getattr(first_root, "Group", [])]
        App.Console.PrintMessage(f"[950Surf] First_Floor children: {kids}\n")
    if second_root:
        kids2 = [getattr(o, "Label", o.Name) for o in getattr(second_root, "Group", [])]
        App.Console.PrintMessage(f"[950Surf] Second_Floor children: {kids2}\n")
except Exception:
    pass

# Optional save (after grouping so structure is persisted)
if save_path:
    try:
        doc.saveAs(save_path)
        App.Console.PrintMessage(f"[950Surf] Saved model to {save_path}\n")
    except Exception as e:
        App.Console.PrintError(f"[950Surf] Failed to save model to {save_path}: {e}\n")

try:
    import FreeCADGui as Gui
    if Gui.ActiveDocument:
        v = Gui.ActiveDocument.ActiveView
        v.setCameraType("Orthographic")
        v.viewIsometric()
        v.fitAll()
except Exception:
    pass
