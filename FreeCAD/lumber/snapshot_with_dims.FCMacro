# FreeCAD macro: create a dimensioned top-view snapshot of the current module (joists or studs).
# - Scopes to the selected group if exactly one is selected; otherwise uses all solids in the doc.
# - Adds overall X/Y dimensions and bay spacing dimensions between adjacent members (joists or studs).
# - Sets camera to top/orthographic and exports a PNG alongside this macro.
# - Cleans up the temporary dimensions after export.

import os
import FreeCAD as App
import FreeCADGui as Gui
import Draft

doc = App.ActiveDocument
if not doc:
    raise RuntimeError("No active document.")

# Scope: if exactly one group is selected, operate on its children; else all solids
sel = Gui.Selection.getSelection()
if len(sel) == 1 and hasattr(sel[0], "Group"):
    candidates = sel[0].Group
else:
    candidates = doc.Objects

objs = [o for o in candidates if hasattr(o, "Shape") and not o.isDerivedFrom("Sketcher::SketchObject")]
if not objs:
    raise RuntimeError("No solids found to dimension.")

# Compute combined bounding box
bb = None
for o in objs:
    b = o.Shape.BoundBox
    bb = b if bb is None else bb.united(b)

def inch(val_mm):
    return val_mm / 25.4

# Helpers to make dimension between two points
def make_dim(p1, p2, dim_dir):
    dim = Draft.make_dimension(p1, p2, dim_dir)
    dim.ViewObject.LineColor = (1.0, 1.0, 1.0)
    dim.ViewObject.TextColor = (1.0, 1.0, 1.0)
    dim.ViewObject.ArrowSize = 3
    dim.ViewObject.FontSize = 80
    dim.ViewObject.ShowUnit = True
    # Some builds don't expose a "3D" display mode; fall back silently
    try:
        dim.ViewObject.DisplayMode = "3D"
    except Exception:
        pass
    return dim

temp_dims = []

# Overall length (X direction) along lower edge
p1_len = App.Vector(bb.XMin, bb.YMin, bb.ZMin)
p2_len = App.Vector(bb.XMax, bb.YMin, bb.ZMin)
dim_len = make_dim(p1_len, p2_len, App.Vector((bb.XMin + bb.XMax)/2, bb.YMin - (bb.YMax - bb.YMin)*0.05, bb.ZMin))
temp_dims.append(dim_len)

# Overall width (Y direction) along left edge
p1_w = App.Vector(bb.XMin, bb.YMin, bb.ZMin)
p2_w = App.Vector(bb.XMin, bb.YMax, bb.ZMin)
dim_w = make_dim(p1_w, p2_w, App.Vector(bb.XMin - (bb.XMax - bb.XMin)*0.05, (bb.YMin + bb.YMax)/2, bb.ZMin))
temp_dims.append(dim_w)

# Member spacing (joists or studs): dimension every bay (between faces) and highlight large openings
members = [o for o in objs if any(k in o.Name or k in o.Label for k in ("Joist", "Stud"))]
if len(members) >= 2:
    # Decide spacing axis by which center range is larger (studs run along Y, joists spacing also along Y)
    centers_x = []
    centers_y = []
    boxes = {}
    for m in members:
        b = m.Shape.BoundBox
        boxes[m.Name] = b
        centers_x.append((m.Name, (b.XMin + b.XMax) / 2.0))
        centers_y.append((m.Name, (b.YMin + b.YMax) / 2.0))

    def range_of(values):
        nums = [v for _, v in values]
        return max(nums) - min(nums) if nums else 0

    axis = "Y" if range_of(centers_y) >= range_of(centers_x) else "X"
    centers = centers_y if axis == "Y" else centers_x
    centers.sort(key=lambda x: x[1])

    # Build bay dimensions between adjacent faces
    if axis == "Y":
        x_mid = (bb.XMin + bb.XMax) / 2.0
        offset = (bb.XMax - bb.XMin) * 0.06
        largest_gaps = []
        for idx in range(len(centers) - 1):
            b_a = boxes[centers[idx][0]]
            b_b = boxes[centers[idx + 1][0]]
            y_a = b_a.YMax
            y_b = b_b.YMin
            p1_s = App.Vector(x_mid, y_a, bb.ZMin)
            p2_s = App.Vector(x_mid, y_b, bb.ZMin)
            dim_s = make_dim(p1_s, p2_s, App.Vector(x_mid + offset, (y_a + y_b) / 2.0, bb.ZMin))
            temp_dims.append(dim_s)
            gap = y_b - y_a
            largest_gaps.append((gap, y_a, y_b))
        # Add explicit dimensions for large openings (e.g., window RO widths)
        for gap, y_a, y_b in largest_gaps:
            if gap >= 609.6:  # 24" in mm
                p1_o = App.Vector(x_mid - offset, y_a, bb.ZMin)
                p2_o = App.Vector(x_mid - offset, y_b, bb.ZMin)
                dim_o = make_dim(p1_o, p2_o, App.Vector(x_mid - offset * 2, (y_a + y_b) / 2.0, bb.ZMin))
                temp_dims.append(dim_o)
    else:
        y_mid = (bb.YMin + bb.YMax) / 2.0
        offset = (bb.YMax - bb.YMin) * 0.06
        for idx in range(len(centers) - 1):
            b_a = boxes[centers[idx][0]]
            b_b = boxes[centers[idx + 1][0]]
            x_a = b_a.XMax
            x_b = b_b.XMin
            p1_s = App.Vector(x_a, y_mid, bb.ZMin)
            p2_s = App.Vector(x_b, y_mid, bb.ZMin)
            dim_s = make_dim(p1_s, p2_s, App.Vector((x_a + x_b) / 2.0, y_mid + offset, bb.ZMin))
            temp_dims.append(dim_s)

doc.recompute()

# Set top view orthographic and fit
view = Gui.ActiveDocument.ActiveView
view.viewTop()
# Fallback for API differences
try:
    view.setOrthographic(True)
except Exception:
    view.setCameraType("Orthographic")
view.fitAll()
# Ensure top view is locked before export
view.viewTop()

# Export to PNG next to the macro
macro_dir = os.path.dirname(__file__)
png_path = os.path.join(macro_dir, "module_snapshot.png")
view.saveImage(png_path, 2000, 1500, "Current")
App.Console.PrintMessage(f"Snapshot saved: {png_path}\n")

# Cleanup temporary dimensions
for d in temp_dims:
    doc.removeObject(d.Name)
doc.recompute()
