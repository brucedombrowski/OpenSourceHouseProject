# -*- coding: utf-8 -*-
"""Build 950 Surf Beach House - Refactored Version

Construction-grade parametric model for 950 Surf Ave beach house.

Architecture:
    - Foundation: 30 pilings (5x6 grid) with double beams and blocking
    - Floor: Two 16x16 joist modules with sheathing
    - Walls: 2x4 framing with window/door openings
    - Stairs: Interior/exterior access
    - Second Floor: Mirrors first floor layout
    - Roof: Gable + shed configurations

Build Sequence (matches group hierarchy):
    1. Lot survey lines
    2. Foundation (piles, beams, blocking)
    3. First floor joists + sheathing
    4. First floor walls
    5. Second floor joists + sheathing
    6. Second floor walls
    7. Stairs
    8. Roofing

Usage:
    Run this macro in FreeCAD. It will generate the complete house model
    and export BOM to beach_bom.csv.

Author: OpenSourceHouseProject
Dedication: For Luke Dombrowski. Stay Alive.
"""

import importlib
import os
import sys

import Part

import FreeCAD as App

# Import BeachHouse helpers and config
# Use absolute paths to work when macro is copied to builds/ folder
_this_file = __file__ if __file__ else os.getcwd()
_macro_location = os.path.dirname(os.path.abspath(_this_file))

# If this macro is in builds/, navigate to DesignHouse root
# Structure: FreeCAD/DesignHouse/builds/macro.FCMacro
# We need to get to: FreeCAD/DesignHouse/
if os.path.basename(_macro_location) == "builds":
    # Go up from builds/ -> DesignHouse/
    _design_house_root = os.path.dirname(_macro_location)
else:
    # Macro is in DesignHouse/ directly (template location)
    _design_house_root = _macro_location

_macros_dir = os.path.join(_design_house_root, "macros")

if _macros_dir not in sys.path:
    sys.path.append(_macros_dir)
if _design_house_root not in sys.path:
    sys.path.append(_design_house_root)

try:
    import beach_common as bc
    import beach_elevator as be
    import beam_assemblies as ba
    import pile_connections as pc
    import septic_utilities as su
    BEACH_COMMON_AVAILABLE = True
except ImportError:
    App.Console.PrintError(
        "[Build_950Surf] Required modules not found; cannot proceed.\n"
        "Ensure all helper modules exist in macros/ directory:\n"
        "  - beach_common.py, beam_assemblies.py, septic_utilities.py\n"
        "  - beach_elevator.py, pile_connections.py\n"
    )
    raise

# Import design configuration
# BEACH_CONFIG env var MUST point to a config file (e.g., "ExampleBeachHouse/config.py")
beach_config_path = os.environ.get("BEACH_CONFIG", "")

if not beach_config_path:
    App.Console.PrintError("[BeachHouse] ERROR: BEACH_CONFIG environment variable not set.\n")
    App.Console.PrintError("[BeachHouse] Please set BEACH_CONFIG to your config file path.\n")
    App.Console.PrintError("[BeachHouse] Example: export BEACH_CONFIG=ExampleBeachHouse/config.py\n")
    raise RuntimeError("BEACH_CONFIG environment variable not set")

# Load config from specified path
try:
    import importlib.util
    spec = importlib.util.spec_from_file_location("beach_config", beach_config_path)
    beach_config = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(beach_config)
    LOT = beach_config.LOT
    FOUNDATION = beach_config.FOUNDATION
    FIRST_FLOOR = beach_config.FIRST_FLOOR
    SEPTIC_SYSTEM = beach_config.SEPTIC_SYSTEM
    UTILITIES = beach_config.UTILITIES
    DECKS = beach_config.DECKS
    DRIVEWAY = beach_config.DRIVEWAY
    ELEVATOR = beach_config.ELEVATOR
    STAIRS = beach_config.STAIRS
    WALLS = beach_config.WALLS
    BUILD = beach_config.BUILD
    App.Console.PrintMessage(f"[BeachHouse] Loaded design configuration from {beach_config_path}\n")
except Exception as e:
    App.Console.PrintError(f"[BeachHouse] Failed to load config from {beach_config_path}: {e}\n")
    raise

# ============================================================
# EXTRACT PARAMETERS FROM CONFIG
# ============================================================

# Lot geometry
lot_x_ft = LOT["width_ft"]
lot_y_ft = LOT["depth_ft"]
front_setback_ft = LOT["front_setback_ft"]  # South side
left_setback_ft = LOT["left_setback_ft"]    # West side
right_setback_ft = LOT["right_setback_ft"]  # East side
rear_setback_ft = LOT["rear_setback_ft"]    # North side

# Foundation
pile_label = "12x12x40_piling_PT"
pile_length_ft = FOUNDATION["pile_length_ft"]
embed_depth_ft = FOUNDATION["pile_embed_depth_ft"]
above_grade_ft = pile_length_ft - embed_depth_ft  # CALCULATED: top of foundation above grade
pile_base_z_in = -embed_depth_ft * 12.0

# Pile grid
num_piles_x = FOUNDATION["pile_grid_x"]
num_piles_y = FOUNDATION["pile_grid_y"]
y_spacing_ft = FOUNDATION["pile_spacing_y_ft"]

# Pile thickness (for face alignment calculations)
pile_thickness_ft = FOUNDATION["pile_actual_size_in"] / 12.0
pile_half_thickness_ft = pile_thickness_ft / 2.0

# X positions: outside faces of outside columns align with setback lines
# West pile: west face at left setback line, so center = left_setback + half_thickness
# East pile: east face at right setback line, so center = lot_width - right_setback - half_thickness
# Interior piles: evenly spaced between west and east piles
west_pile_center_x_ft = left_setback_ft + pile_half_thickness_ft
east_pile_center_x_ft = lot_x_ft - right_setback_ft - pile_half_thickness_ft
if num_piles_x > 1:
    x_spacing_ft = (east_pile_center_x_ft - west_pile_center_x_ft) / (num_piles_x - 1)
else:
    x_spacing_ft = 0.0
x_positions_ft = [west_pile_center_x_ft + i * x_spacing_ft for i in range(num_piles_x)]

# Y positions: front pile face at front setback
# Shift center by half pile thickness so face aligns with setback
start_y_ft = front_setback_ft + pile_half_thickness_ft
y_positions_ft = [start_y_ft + i * y_spacing_ft for i in range(num_piles_y)]

# Beam parameters (double-beam assemblies running along Y)
beam_label = "beam_2x12x192_PT"
beam_row_step = FOUNDATION["beam_row_interval"]
beam_gap_in = FOUNDATION["beam_gap_in"]

# Blocking parameters (lateral support per IRC R502.7)
blocking_offsets_ft = FOUNDATION["blocking_offsets_ft"]

# Mid-span boards (additional support between pile rows)
mid_board_label = "beam_2x12x96_PT"
mid_board_offset_L_in = FOUNDATION["mid_board_offset_left_in"]
mid_board_offset_R_in = FOUNDATION["mid_board_offset_right_in"]

# Joist module parameters (from config)
module_x_ft = 16.0
module_y_ft = 16.0
module_joist_label = "joist_2x12_PT"
module_first_spacing_in = FIRST_FLOOR["joist_first_spacing_in"]
module_joist_spacing_in = FIRST_FLOOR["joist_spacing_oc_in"]
module_left_x_ft = lot_x_ft / 2.0  # Align to lot centerline
module_front_y_ft = front_setback_ft
module_base_z_ft = above_grade_ft

# Sheathing parameters
sheathing_thick_in = FIRST_FLOOR["sheathing_thickness_in"]
sheathing_label = FIRST_FLOOR["sheathing_stock"]

# Hanger parameters (from config)
hanger_label = "hanger_LU210"
hanger_thickness_in = FIRST_FLOOR["hanger_thickness_in"]
hanger_height_in = FIRST_FLOOR["hanger_height_in"]
hanger_seat_depth_in = FIRST_FLOOR["hanger_seat_depth_in"]
hanger_color = None

# ============================================================
# CATALOG LOADING
# ============================================================

App.Console.PrintMessage("[Build_950Surf] Loading catalogs...\n")
catalog = bc.load_beach_catalog()
bc.print_catalog_summary(catalog)

# ============================================================
# DOCUMENT SETUP
# ============================================================

doc = App.newDocument("950Surf")
App.Console.PrintMessage("[Build_950Surf] Created document: 950Surf\n")

# ============================================================
# SECTION 1: LOT SURVEY (Boundary + Buildable Area + Origin)
# ============================================================

def create_lot_survey(doc, lot_x_ft, lot_y_ft, front_setback_ft, left_setback_ft, right_setback_ft, rear_setback_ft):
    """Create lot survey boundary, buildable area, and origin marker.

    Construction Notes:
        - Lot boundary shows property lines (legal survey)
        - Buildable area shows zoning envelope (setbacks applied)
        - Origin marker at (0,0) for reference

    Args:
        doc: FreeCAD document
        lot_x_ft: Lot width in feet (X, east-west)
        lot_y_ft: Lot depth in feet (Y, north-south)
        front_setback_ft: Front (south) setback per zoning
        left_setback_ft: Left (west) setback per zoning
        right_setback_ft: Right (east) setback per zoning
        rear_setback_ft: Rear (north) setback per zoning

    Returns:
        lot_grp: DocumentObjectGroup containing lot geometry
    """
    App.Console.PrintMessage("[Build_950Surf] Creating lot survey...\n")

    # Lot boundary (property lines)
    lot_pts = [
        App.Vector(0, 0, 0),
        App.Vector(bc.ft(lot_x_ft), 0, 0),
        App.Vector(bc.ft(lot_x_ft), bc.ft(lot_y_ft), 0),
        App.Vector(0, bc.ft(lot_y_ft), 0),
        App.Vector(0, 0, 0),  # Close polygon
    ]
    lot_wire = Part.makePolygon(lot_pts)
    lot_obj = doc.addObject("Part::Feature", "Lot_Boundary")
    lot_obj.Shape = lot_wire

    # Buildable area (zoning envelope)
    buildable_pts = [
        App.Vector(bc.ft(left_setback_ft), bc.ft(front_setback_ft), 0),
        App.Vector(bc.ft(lot_x_ft - right_setback_ft), bc.ft(front_setback_ft), 0),
        App.Vector(bc.ft(lot_x_ft - right_setback_ft), bc.ft(lot_y_ft - rear_setback_ft), 0),
        App.Vector(bc.ft(left_setback_ft), bc.ft(lot_y_ft - rear_setback_ft), 0),
        App.Vector(bc.ft(left_setback_ft), bc.ft(front_setback_ft), 0),
    ]
    buildable_wire = Part.makePolygon(buildable_pts)
    buildable_obj = doc.addObject("Part::Feature", "Buildable_Area")
    buildable_obj.Shape = buildable_wire

    # Origin marker (cross at 0,0)
    marker_size_ft = LOT.get("origin_marker_size_ft", 1.0)
    cross_lines = [
        Part.makeLine(App.Vector(-bc.ft(marker_size_ft), 0, 0), App.Vector(bc.ft(marker_size_ft), 0, 0)),
        Part.makeLine(App.Vector(0, -bc.ft(marker_size_ft), 0), App.Vector(0, bc.ft(marker_size_ft), 0)),
    ]
    cross_obj = doc.addObject("Part::Feature", "Origin_Marker")
    cross_obj.Shape = Part.Compound(cross_lines)

    # Group lot objects
    lot_grp = bc.create_group(doc, "Lot")
    bc.add_to_group(lot_grp, [lot_obj, buildable_obj, cross_obj])

    App.Console.PrintMessage("[Build_950Surf] Lot survey complete.\n")
    return lot_grp

# Create lot survey
lot_grp = create_lot_survey(doc, lot_x_ft, lot_y_ft, front_setback_ft, left_setback_ft, right_setback_ft, rear_setback_ft)

# ============================================================
# SECTION 2: SEPTIC SYSTEM (if enabled)
# ============================================================

if BUILD.get("include_septic_system", False):
    App.Console.PrintMessage("[Build_950Surf] === SEPTIC SYSTEM ===\n")
    septic_grp = su.create_septic_system(doc, SEPTIC_SYSTEM)
else:
    App.Console.PrintMessage("[Build_950Surf] Septic system skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 3: FOUNDATION (Piles, Beams, Blocking, Mid-Boards)
# ============================================================

def create_foundation(doc, catalog, params):
    """Build pile foundation with LVL beam assemblies.

    Construction Sequence:
        1. Install pilings (35 ea, 12x12x40 PT, embedded 20' below grade)
        2. Install LVL beam assemblies (1.75"×depth×20' 2-ply, centered on piles)
        3. Notch piles for beam seats (single 3.5" wide notch per pile)

    Design Rationale:
        - Pile grid: 5×7 = 35 piles @ 10' OC (efficient use of 20' LVL stock)
        - Embed depth: 20' below grade (local code + storm surge + safety factor)
        - Above grade: 20' (elevated above max flood elevation per FEMA)
        - LVL beams: 2-ply laminated (3.5" total width) centered on piles
        - Three 20' segments per girder: rows 1-3, 3-5, 5-7
        - Single notch per pile: 3.5" wide × depth deep

    Args:
        doc: FreeCAD document
        catalog: Catalog rows from beach_common
        params (dict): Foundation parameters with keys:
            - pile_label, x_positions_ft, y_positions_ft, pile_base_z_in, pile_height_in
            - lvl_label (e.g., "lvl_1.75x11.875x240")

    Returns:
        foundation_grp: DocumentObjectGroup with subgroups:
            - Piles (35 ea)
            - LVL_Beam_Assemblies (15 assemblies: 5 girders × 3 segments each)

    Raises:
        ValueError: If pile_label or lvl_label not found in catalog
    """
    App.Console.PrintMessage("[Build_950Surf] Building foundation with LVL beams...\n")

    # Lookup catalog entries (fail-fast if not found)
    pile_row = bc.find_stock(catalog, params["pile_label"])
    lvl_row = bc.find_stock(catalog, params["lvl_label"])

    # Extract dimensions from catalog
    pile_width_in = float(pile_row["actual_width_in"])
    pile_thick_in = float(pile_row["actual_thickness_in"])
    pile_len_in = float(pile_row["length_in"])

    lvl_ply_thick_in = float(lvl_row["actual_thickness_in"])  # 1.75"
    lvl_depth_in = float(lvl_row["actual_width_in"])  # Variable (11.875", 24", etc.)
    lvl_total_width_in = lvl_ply_thick_in * 2  # 3.5" (2 plies)

    # Calculate Z positions
    pile_height_in = params["pile_height_in"]
    beam_top_z_in = params["pile_base_z_in"] + pile_len_in
    beam_base_z_in = beam_top_z_in - lvl_depth_in

    # === CREATE PILES ===
    App.Console.PrintMessage("[Build_950Surf]   Creating piles...\n")
    pile_objs = []
    for xi_ft in params["x_positions_ft"]:
        for yi_ft in params["y_positions_ft"]:
            name = f"Pile_{int(xi_ft)}_{int(yi_ft)}"
            pile = bc.make_pile(
                doc, catalog, params["pile_label"], name,
                xi_ft, yi_ft, params["pile_base_z_in"], pile_height_in
            )
            pile_objs.append(pile)

    App.Console.PrintMessage(f"[Build_950Surf]   Created {len(pile_objs)} piles.\n")

    # === CREATE LVL BEAM ASSEMBLIES ===
    App.Console.PrintMessage("[Build_950Surf]   Creating LVL beam assemblies (3 segments per girder)...\n")
    lvl_assemblies = []

    # Validate pile count (must be 7 for standard 3-segment pattern)
    if len(params["y_positions_ft"]) != 7:
        raise ValueError(
            f"LVL beam system requires 7 pile rows, got {len(params['y_positions_ft'])}"
        )

    # Create 3 LVL segments for each girder line (5 girders × 3 segments = 15 assemblies)
    # Determine LVL placement side: west girders on west face, east girders on east face
    middle_x_ft = (params["x_positions_ft"][0] + params["x_positions_ft"][-1]) / 2.0

    for girder_idx, xi_ft in enumerate(params["x_positions_ft"]):
        # West girders (X < middle): place LVL on west face of pile
        # East girders (X > middle): place LVL on east face of pile
        # Middle girder (X = middle): use west face for simplicity
        lvl_side = "west" if xi_ft <= middle_x_ft else "east"

        assemblies = ba.create_lvl_beam_segments_for_girder(
            doc,
            catalog,
            x_girder_ft=xi_ft,
            y_pile_positions_ft=params["y_positions_ft"],
            z_base_in=beam_base_z_in,
            lvl_label=params["lvl_label"],
            girder_idx=girder_idx,
            side=lvl_side,
        )
        lvl_assemblies.extend(assemblies)

    App.Console.PrintMessage(f"[Build_950Surf]   Created {len(lvl_assemblies)} LVL beam assemblies.\n")

    # === PILE-TO-BEAM CONNECTIONS (notches + bolts) ===
    # Delegate to pile_connections module for notching and bolt creation
    # This handles:
    #   - Notch type detection (endpoint corner vs middle/boundary full-width)
    #   - Segment boundary detection (where two LVL segments meet)
    #   - Threaded rod placement with proper Y positioning (centered on notched half)
    #   - Rod X positioning (centered on pile with protrusion on both ends)
    #   - Rod Z positioning (equal thirds: 1/3 and 2/3 of beam depth)
    notch_count, notched_piles, anchor_bolts_created = pc.create_all_pile_connections(
        doc,
        catalog,
        pile_objs,
        lvl_assemblies,
        pile_width_in,
        pile_thick_in,
        lvl_total_width_in,
        lvl_depth_in,
        beam_base_z_in,
    )

    # === GROUP FOUNDATION ===
    foundation_grp = bc.create_group(doc, "Foundation")
    piles_grp = bc.create_group(doc, "Piles")
    lvl_beam_assemblies_grp = bc.create_group(doc, "LVL_Beam_Assemblies")
    anchor_bolts_grp = bc.create_group(doc, "Anchor_Bolts")

    bc.add_to_group(piles_grp, pile_objs)
    bc.add_to_group(lvl_beam_assemblies_grp, lvl_assemblies)
    bc.add_to_group(anchor_bolts_grp, anchor_bolts_created)
    bc.add_to_group(foundation_grp, [piles_grp, lvl_beam_assemblies_grp, anchor_bolts_grp])

    App.Console.PrintMessage("[Build_950Surf] Foundation complete.\n")
    return foundation_grp

# Create foundation
foundation_params = {
    "pile_label": pile_label,
    "x_positions_ft": x_positions_ft,
    "y_positions_ft": y_positions_ft,
    "pile_base_z_in": pile_base_z_in,
    "pile_height_in": above_grade_ft * 12.0 - pile_base_z_in,
    "lvl_label": FOUNDATION.get("lvl_label", "lvl_1.75x11.875x240"),  # LVL beam catalog key
}

foundation_grp = create_foundation(doc, catalog, foundation_params)

# ============================================================
# SECTION 4: UTILITIES AND CONCRETE SLAB (if enabled)
# ============================================================

if BUILD.get("include_concrete_slab", BUILD.get("include_utilities", False)):
    App.Console.PrintMessage("[Build_950Surf] === CONCRETE SLAB ===\n")
    # Pass pile positions for slab cutouts (use actual pile size, not nominal)
    pile_positions_ft = [(x, y) for x in x_positions_ft for y in y_positions_ft]
    slab_grp = su.create_concrete_slab_group(
        doc,
        UTILITIES,
        pile_positions_ft=pile_positions_ft,
        pile_size_in=FOUNDATION.get("pile_actual_size_in", FOUNDATION["pile_size_in"])
    )
else:
    App.Console.PrintMessage("[Build_950Surf] Concrete slab skipped (disabled in BUILD config)\n")

if BUILD.get("include_utilities", False):
    App.Console.PrintMessage("[Build_950Surf] === UTILITIES ===\n")
    # Pass STAIRS, FOUNDATION, and LOT configs for foot wash station and pile hose bibs
    utilities_grp = su.create_utilities_group(doc, UTILITIES, stairs_config=STAIRS, foundation_config=FOUNDATION, lot_config=LOT)
else:
    App.Console.PrintMessage("[Build_950Surf] Utilities skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 4.4: DRIVEWAY SLAB (with rebar)
# ============================================================

if BUILD.get("include_driveway", False):
    App.Console.PrintMessage("[Build_950Surf] === DRIVEWAY ===\n")
    # Pass UTILITIES config to create cutouts for water boxes (dependency tracking)
    driveway_grp = su.create_driveway_slab_group(doc, DRIVEWAY, utilities_config=UTILITIES)
else:
    App.Console.PrintMessage("[Build_950Surf] Driveway skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 4.4: BEACH ELEVATOR (open metal lift)
# ============================================================

if BUILD.get("include_elevator", False):
    App.Console.PrintMessage("[Build_950Surf] === BEACH ELEVATOR ===\n")
    elevator_grp = be.create_beach_elevator(doc, ELEVATOR, foundation_config=FOUNDATION)
else:
    App.Console.PrintMessage("[Build_950Surf] Beach elevator skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 4.45: EXTERIOR STAIRS (from slab to floor)
# ============================================================

if BUILD.get("include_stairs", False):
    App.Console.PrintMessage("[Build_950Surf] === EXTERIOR STAIRS ===\n")
    stairs_grp = su.create_exterior_stairs(doc, STAIRS, floor_z_ft=above_grade_ft, slab_z_ft=0.0)
else:
    App.Console.PrintMessage("[Build_950Surf] Exterior stairs skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 4.5: DECK JOISTS (installed BEFORE first floor sheathing)
# ============================================================

if BUILD.get("include_deck_joists", False):
    App.Console.PrintMessage("[Build_950Surf] Building deck joists...\n")

    # Import modules (already in sys.path via _macros_dir)
    import deck_assemblies as da
    import lumber_common as lc
    import parts
    importlib.reload(da)
    importlib.reload(parts)

    # Load catalog for deck assemblies
    catalog_path = os.path.join(_design_house_root, "lumber", "lumber_catalog.csv")
    catalog_rows = lc.load_catalog(catalog_path)

    deck_z_base_in = above_grade_ft * 12.0  # Same level as foundation top

    # Calculate deck positions
    # Front deck: south of front setback, 12' deep modules with rim offset for alignment
    front_deck_rim_offset_ft = DECKS["front_deck_rim_offset_in"] / 12.0
    front_deck_depth_ft = DECKS["front_deck_depth_ft"]  # 12' for 16x12 modules
    front_deck_y_ft = front_setback_ft + y_spacing_ft - front_deck_depth_ft - front_deck_rim_offset_ft

    # Rear deck: starts at back edge of floor area (3×3 grid of 16x16 modules = 48' deep)
    floor_depth_ft = (FIRST_FLOOR["module_16x16_depth_in"] * 3) / 12.0  # 3 rows × 16' = 48'
    rear_deck_y_ft = front_setback_ft + y_spacing_ft + floor_depth_ft

    # Deck X positioning: snap to first floor joists
    # Floor width from module dimensions (3×3 grid of 16x16 modules = 48' wide)
    floor_width_ft_local = (FIRST_FLOOR["module_16x16_width_in"] * 3) / 12.0  # 3 columns × 16' = 48'
    floor_start_x_ft = (lot_x_ft - floor_width_ft_local) / 2.0  # Center floor on lot
    deck_left_x_ft = floor_start_x_ft  # Snap deck left edge to floor left edge

    deck_joist_assemblies = []

    # ============================================================
    # FRONT DECK: 3 modules of 16x12 (joists run N-S, rims run E-W)
    # Module layout: 16' wide × 12' deep, deck boards run E-W
    # ============================================================
    App.Console.PrintMessage("[Build_950Surf]   Creating front deck joists (3 × 16x12 modules)...\n")

    # Left module (west)
    front_deck_left = parts.create_deck_module_front_16x12(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Left_16x12",
        make_pressure_treated=True,
    )
    lc.place_assembly_at(
        front_deck_left,
        x_ft=deck_left_x_ft,
        y_ft=front_deck_y_ft,
        z_ft=above_grade_ft,
    )
    deck_joist_assemblies.append(front_deck_left)

    # Center module
    front_deck_center = parts.create_deck_module_front_16x12(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Center_16x12",
        make_pressure_treated=True,
    )
    lc.snap_assembly_corner_to_corner(
        front_deck_center, front_deck_left, target_corner="bottom_right", assembly_corner="bottom_left"
    )
    deck_joist_assemblies.append(front_deck_center)

    # Right module (east)
    front_deck_right = parts.create_deck_module_front_16x12(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Right_16x12",
        make_pressure_treated=True,
    )
    lc.snap_assembly_corner_to_corner(
        front_deck_right, front_deck_center, target_corner="bottom_right", assembly_corner="bottom_left"
    )
    deck_joist_assemblies.append(front_deck_right)

    # Rear deck module dimensions (still using old 16x8 layout)
    module_16_width_ft = DECKS["module_16_width_in"] / 12.0
    center_module_width_ft = DECKS["center_module_width_in"] / 12.0

    # Rear deck joists (3 modules using config dimensions)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear deck joists (3 modules from config)...\n")
    rear_deck_joists_left = da.create_deck_joists_16x8(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Joists_Left",
        x_base=deck_left_x_ft * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    deck_joist_assemblies.append(rear_deck_joists_left)

    rear_deck_joists_center = da.create_deck_joists_8ft9in_x_8ft(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Joists_Center",
        x_base=(deck_left_x_ft + module_16_width_ft) * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    # Snap center module to right edge of left module
    lc.snap_assembly_corner_to_corner(
        rear_deck_joists_center, rear_deck_joists_left, target_corner="bottom_right", assembly_corner="bottom_left"
    )
    deck_joist_assemblies.append(rear_deck_joists_center)

    rear_deck_joists_right = da.create_deck_joists_16x8(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Joists_Right",
        x_base=(deck_left_x_ft + module_16_width_ft + center_module_width_ft) * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    # Snap right module to right edge of center module
    lc.snap_assembly_corner_to_corner(
        rear_deck_joists_right, rear_deck_joists_center, target_corner="bottom_right", assembly_corner="bottom_left"
    )
    deck_joist_assemblies.append(rear_deck_joists_right)

    # Create Deck_Joists group
    deck_joists_grp = bc.create_group(doc, "Deck_Joists")
    bc.add_to_group(deck_joists_grp, deck_joist_assemblies)

    App.Console.PrintMessage(f"[Build_950Surf] Deck joists complete ({len(deck_joist_assemblies)} modules).\n")
else:
    App.Console.PrintMessage("[Build_950Surf] Deck joists skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 5: FIRST FLOOR JOISTS (Assembly-Based Modules)
# ============================================================

def create_first_floor_joists(doc, catalog, params, macro_dir):
    """Build first floor using reusable joist module assemblies with snapping.

    Construction Sequence:
        1. Load joist module macros (16x16 assemblies)
        2. Create module instances and position via snapping
        3. NO hard-coded offsets - uses bounding box geometry

    Design Rationale:
        - Reusable modules eliminate code duplication
        - Assembly snapping ensures perfect alignment (0.0000mm gaps)
        - Clean hierarchy: Floor → Module (assembly) → Joists + Hardware

    Floor Layout (3×3 grid pattern):
        - Grid uses (row, col) naming like piles: Floor_R{row}_C{col}
        - Row 1 (front), Row 2 (center), Row 3 (back)
        - Col 1 (left/west), Col 2 (middle), Col 3 (right/east)

        Row 1 (front):  16x16 + 16x16 + 16x16 = 48' wide × 16' deep
        Row 2 (center): 16x16 + 16x16 + 16x16 = 48' wide × 16' deep
        Row 3 (back):   16x16 + 16x16 + 16x16 = 48' wide × 16' deep

        Total: 48' wide × 48' deep (9 identical modules)

    Args:
        doc: FreeCAD document
        catalog: Catalog rows from beach_common
        params (dict): Floor parameters with keys:
            - floor_base_z_ft: Z position for floor deck
            - floor_start_x_ft, floor_start_y_ft: Front-left corner position
        macro_dir: Path to this macro's directory

    Returns:
        floor_grp: DocumentObjectGroup containing floor assemblies
    """
    import importlib

    App.Console.PrintMessage("[Build_950Surf] Building first floor joists (assembly-based)...\n")

    # Import lumber modules
    # macro_dir might be empty when running from FreeCADCmd
    if not macro_dir:
        macro_dir = os.getcwd()

    # Import parts modules (already in sys.path via _macros_dir)
    import lumber_common as lc
    import parts
    importlib.reload(lc)
    importlib.reload(parts)

    # Load catalog (use _design_house_root which is already set correctly)
    catalog_path = os.path.join(_design_house_root, "lumber", "lumber_catalog.csv")
    catalog_rows = lc.load_catalog(catalog_path)
    App.Console.PrintMessage(f"[Build_950Surf]   Loaded {len(catalog_rows)} catalog entries\n")

    modules = []

    # Calculate floor start position (centered on lot)
    module_width_ft = FIRST_FLOOR["module_16x16_width_in"] / 12.0
    floor_width_ft = module_width_ft * 3  # 3 columns × 16' = 48'
    floor_start_x_ft = (params["lot_x_ft"] - floor_width_ft) / 2.0  # Center on lot

    # ============================================================
    # CREATE FLOOR MODULES IN 3×3 GRID PATTERN
    # All modules are 16'×16' for uniform construction
    # Grid: 3 rows × 3 columns = 9 modules = 48' × 48'
    # Row 1 = front (south), Row 2 = center, Row 3 = back (north)
    # Col 1 = left (west), Col 2 = middle, Col 3 = right (east)
    # ============================================================

    # Store modules by grid position for snapping reference
    grid = {}  # grid[(row, col)] = module

    for row in range(1, 4):  # Rows 1, 2, 3 (front, center, back)
        row_name = {1: "Front", 2: "Center", 3: "Back"}[row]
        App.Console.PrintMessage(f"[Build_950Surf]   === ROW {row} ({row_name.upper()}) ===\n")

        for col in range(1, 4):  # Columns 1, 2, 3 (left, middle, right)
            assembly_name = f"Floor_R{row}_C{col}_16x16"

            # Special case: Row 1, Col 3 may need stair cutout
            if row == 1 and col == 3 and BUILD.get("include_stairs", False):
                App.Console.PrintMessage(f"[Build_950Surf]   Creating {assembly_name} (STAIR CUTOUT)...\n")
                module = parts.create_joist_module_16x16_stair_cutout(
                    doc,
                    catalog_rows,
                    assembly_name=assembly_name,
                    make_pressure_treated=False,
                    stair_config=STAIRS,
                )
            else:
                App.Console.PrintMessage(f"[Build_950Surf]   Creating {assembly_name}...\n")
                module = parts.create_joist_module_16x16(
                    doc, catalog_rows, assembly_name=assembly_name, make_pressure_treated=False
                )

            # Position module using snapping
            if row == 1 and col == 1:
                # First module (R1,C1): place at absolute position (anchor for entire floor)
                lc.place_assembly_at(module, x_ft=floor_start_x_ft, y_ft=params["floor_start_y_ft"], z_ft=params["floor_base_z_ft"])
            elif col == 1:
                # First column of subsequent rows: snap to previous row's first column
                prev_module = grid[(row - 1, 1)]
                lc.snap_assembly_corner_to_corner(module, prev_module, target_corner="top_left", assembly_corner="bottom_left")
            else:
                # Columns 2 and 3: snap to left neighbor in same row
                left_neighbor = grid[(row, col - 1)]
                lc.snap_assembly_corner_to_corner(module, left_neighbor, target_corner="bottom_right", assembly_corner="bottom_left")

            grid[(row, col)] = module
            modules.append(module)

    # ============================================================
    # GROUP ALL MODULES
    # ============================================================
    floor_grp = bc.create_group(doc, "First_Floor_Joists")
    bc.add_to_group(floor_grp, modules)

    App.Console.PrintMessage(f"[Build_950Surf]   ✓ Created {len(modules)} floor modules (3×3 grid = 48' × 48')\n")
    App.Console.PrintMessage("[Build_950Surf] First floor joists complete.\\n")

    return floor_grp

# Create first floor joists
# Calculate floor start position from module dimensions in config
# Floor layout: 3×3 grid of 16'×16' modules = 48' × 48'
floor_width_ft = (FIRST_FLOOR["module_16x16_width_in"] * 3) / 12.0  # 3 columns × 16' = 48'
floor_depth_ft = (FIRST_FLOOR["module_16x16_depth_in"] * 3) / 12.0  # 3 rows × 16' = 48'

if BUILD.get("include_first_floor", False):
    floor_params = {
        "floor_base_z_ft": above_grade_ft,
        "floor_start_x_ft": (lot_x_ft - floor_width_ft) / 2.0,  # Center on lot
        "floor_start_y_ft": front_setback_ft + y_spacing_ft,  # Start at second row of piles
        "lot_x_ft": lot_x_ft,  # Pass lot width for center calculation
    }

    floor_grp = create_first_floor_joists(doc, catalog, floor_params, _macros_dir)
else:
    App.Console.PrintMessage("[Build_950Surf] First floor joists skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 5.5: STAIR OPENING (integrated into floor joist assembly above)
# ============================================================
# Stair opening is now created directly in the Floor_Front_Right_16x16 module
# using create_joist_module_16x16_stair_cutout() when BUILD["include_stairs"] = True
# This approach:
# - Shortens joists that conflict with stair headroom
# - Adds a rim joist at the stair cutout edge to frame the opening
# - Places hangers on both sides of the stair rim (shortened joists + full-length joists)

# ============================================================
# SECTION 6: FIRST FLOOR SHEATHING
# ============================================================

if BUILD.get("include_first_floor", False):
    App.Console.PrintMessage("[Build_950Surf] Adding first floor sheathing...\n")

    # Import lumber modules for sheathing (already in sys.path via _macros_dir)
    import importlib

    import lumber_common as lc
    import parts
    importlib.reload(lc)
    importlib.reload(parts)

    # Load lumber catalog for sheathing panels
    catalog_path = os.path.join(_design_house_root, "lumber", "lumber_catalog.csv")
    catalog_rows = lc.load_catalog(catalog_path)

    # Create a simple bounding box from known floor layout dimensions
    # Floor is 40.75' x 40' (from params above)
    floor_start_x_mm = bc.ft(floor_params["floor_start_x_ft"])
    floor_start_y_mm = bc.ft(floor_params["floor_start_y_ft"])
    floor_width_mm = bc.ft(floor_width_ft)
    floor_depth_mm = bc.ft(floor_depth_ft)
    joist_depth_in = FIRST_FLOOR["joist_depth_in"]
    floor_z_top_mm = bc.ft(floor_params["floor_base_z_ft"]) + bc.inch(joist_depth_in)  # Top of joists

    # Create a simple bbox-like object
    class SimpleBBox:
        def __init__(self, xmin, ymin, xmax, ymax, zmax):
            self.XMin = xmin
            self.YMin = ymin
            self.XMax = xmax
            self.YMax = ymax
            self.ZMax = zmax
            self.XLength = xmax - xmin
            self.YLength = ymax - ymin

    floor_bbox = SimpleBBox(
        floor_start_x_mm,
        floor_start_y_mm,
        floor_start_x_mm + floor_width_mm,
        floor_start_y_mm + floor_depth_mm,
        floor_z_top_mm
    )

    # Create sheathing panels (exclude deck areas from config)
    deck_exclusion_ft = FIRST_FLOOR["sheathing_deck_exclusion_ft"]
    sheathing_grp = parts.create_sheathing_for_floor(
        doc,
        catalog_rows,
        floor_bbox,
        z_offset_in=0.0,  # Sheathing sits ON TOP of joists
        group_name="First_Floor_Sheathing",
        panel_label=FIRST_FLOOR["sheathing_stock"],
        exclude_left_ft=deck_exclusion_ft,
        exclude_right_ft=deck_exclusion_ft,
    )

    App.Console.PrintMessage("[Build_950Surf] First floor sheathing complete.\n")

    # Create top-level First_Floor group to organize joists and sheathing
    # (walls will be added to this group later)
    first_floor_parent = bc.create_group(doc, "First_Floor")
    bc.add_to_group(first_floor_parent, [floor_grp, sheathing_grp])
    App.Console.PrintMessage("[Build_950Surf] First floor joists and sheathing organized.\n")

# ============================================================
# SECTION 7: WALLS (Front and Rear - BUTT walls)
# ============================================================
# FRAMING APPROACH: Front/rear walls are BUTT walls, side walls are THROUGH walls
#   - Front/rear walls run full width (40') at sheathing edges (this section)
#   - Side walls fit BETWEEN front/rear walls (see Section 8B)
#   - Butt walls terminate at corners; through walls provide continuous plates

if BUILD.get("include_walls", False):
    App.Console.PrintMessage("[Build_950Surf] Building walls...\n")

    # Import wall assembly module
    import wall_assemblies as wa
    importlib.reload(wa)

    # Wall positioning parameters
    # Walls sit on top of floor sheathing
    joist_depth_in = FIRST_FLOOR["joist_depth_in"]
    sheathing_thickness_in = FIRST_FLOOR["sheathing_thickness_in"]
    wall_z_base_in = (floor_params["floor_base_z_ft"] * 12.0) + joist_depth_in + sheathing_thickness_in

    # Front wall: aligned with sheathing, offset from config
    sheathing_x_start_ft = floor_params["floor_start_x_ft"] + deck_exclusion_ft
    sheathing_y_start_ft = floor_params["floor_start_y_ft"]

    # Wall positioning from config
    wall_offset_ft = WALLS["front_wall_offset_from_sheathing_ft"]
    front_wall_x_start_ft = sheathing_x_start_ft + wall_offset_ft
    front_wall_y_ft = sheathing_y_start_ft

    # Sheathing width = 40' (5 × 8' wall modules)
    sheathing_width_ft = 40.0

    # Wall assemblies are created in default orientation (Y = wall length)
    # Then rotated 90° around Z to run along X (front of house)
    # After rotation: X = wall length (along front), Y = wall thickness (depth into house), Z = vertical

    # Front wall module positions (left to right, 8' each)
    # Module layout: Window | Window | Door | Window | Window = 40' total
    # Matches 40' buildable width (5 modules × 8')
    wall_assemblies = []

    # Get wall module width from config
    wall_module_width_ft = WALLS["wall_module_width_ft"]

    # Helper to rotate wall 90° around Z axis
    def rotate_wall_90(wall, x_offset_ft):
        """Rotate wall 90° CCW around Z axis and snap bottom-left corner to sheathing"""
        # Wall is created at origin with orientation: X=thickness, Y=length, Z=vertical
        # Rotate 90° CCW around Z: new orientation is X=length, Y=thickness, Z=vertical
        wall.Placement.Rotation = App.Rotation(App.Vector(0, 0, 1), 90)

        # Snap bottom-left corner of wall to sheathing
        wall_x_ft = front_wall_x_start_ft + x_offset_ft
        wall_y_ft_corner = front_wall_y_ft

        wall.Placement.Base = App.Vector(
            bc.ft(wall_x_ft),
            bc.ft(wall_y_ft_corner),
            bc.inch(wall_z_base_in)
        )

    # Module 1: Window (far left)
    App.Console.PrintMessage("[Build_950Surf]   Creating front wall module 1 (window)...\n")
    wall_1 = wa.create_window_wall_double_3x5(
        doc, catalog_rows, assembly_name="Front_Wall_1_Window",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_wall_90(wall_1, x_offset_ft=0.0)
    wall_assemblies.append(wall_1)

    # Module 2: Window (left)
    App.Console.PrintMessage("[Build_950Surf]   Creating front wall module 2 (window)...\n")
    wall_2 = wa.create_window_wall_double_3x5(
        doc, catalog_rows, assembly_name="Front_Wall_2_Window",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_wall_90(wall_2, x_offset_ft=wall_module_width_ft * 1.0)
    wall_assemblies.append(wall_2)

    # Module 3: Sliding door (center)
    App.Console.PrintMessage("[Build_950Surf]   Creating front wall module 3 (door)...\n")
    wall_3 = wa.create_sliding_door_72x80(
        doc, catalog_rows, assembly_name="Front_Wall_3_Door",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_wall_90(wall_3, x_offset_ft=wall_module_width_ft * 2.0)
    wall_assemblies.append(wall_3)

    # Module 4: Window (right)
    App.Console.PrintMessage("[Build_950Surf]   Creating front wall module 4 (window)...\n")
    wall_4 = wa.create_window_wall_double_3x5(
        doc, catalog_rows, assembly_name="Front_Wall_4_Window",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_wall_90(wall_4, x_offset_ft=wall_module_width_ft * 3.0)
    wall_assemblies.append(wall_4)

    # Module 5: Window (far right)
    App.Console.PrintMessage("[Build_950Surf]   Creating front wall module 5 (window)...\n")
    wall_5 = wa.create_window_wall_double_3x5(
        doc, catalog_rows, assembly_name="Front_Wall_5_Window",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_wall_90(wall_5, x_offset_ft=wall_module_width_ft * 4.0)
    wall_assemblies.append(wall_5)

    # Create Front_Wall group to organize all wall assemblies
    front_wall_grp = bc.create_group(doc, "Front_Wall")
    bc.add_to_group(front_wall_grp, wall_assemblies)

    App.Console.PrintMessage(f"[Build_950Surf] Front wall complete ({len(wall_assemblies)} modules).\n")

# ============================================================
# SECTION 8: REAR WALL (Window | Door | Window | Door | Window)
# ============================================================

if BUILD.get("include_walls", False):
    App.Console.PrintMessage("[Build_950Surf] Building rear wall...\n")

    # Rear wall positioning: mirror of front wall, at back edge of sheathing
    # Sheathing depth from floor module depths
    sheathing_depth_ft = floor_depth_ft
    rear_wall_x_start_ft = front_wall_x_start_ft
    rear_wall_y_ft = sheathing_y_start_ft + sheathing_depth_ft  # Back edge of sheathing
    rear_wall_assemblies = []

    # Get wall thickness from config
    wall_thickness_in = WALLS["wall_thickness_in"]

    # Helper to rotate and position rear wall
    def rotate_rear_wall_90(wall, x_offset_ft):
        """Rotate wall 90° CCW around Z axis and position at rear of house"""
        wall.Placement.Rotation = App.Rotation(App.Vector(0, 0, 1), 90)

        # Position at rear edge, accounting for wall thickness
        wall_x_ft = rear_wall_x_start_ft + x_offset_ft
        wall_y_ft_corner = rear_wall_y_ft - (wall_thickness_in / 12.0)

        wall.Placement.Base = App.Vector(
            bc.ft(wall_x_ft),
            bc.ft(wall_y_ft_corner),
            bc.inch(wall_z_base_in)
        )

    # Rear wall module layout: Window | Door | Window | Door | Window = 40' total
    # Module 1: Window (far left)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear wall module 1 (window)...\n")
    rear_1 = wa.create_window_wall_double_3x5(
        doc, catalog_rows, assembly_name="Rear_Wall_1_Window",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_rear_wall_90(rear_1, x_offset_ft=0.0)
    rear_wall_assemblies.append(rear_1)

    # Module 2: Sliding door (left)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear wall module 2 (door)...\n")
    rear_2 = wa.create_sliding_door_72x80(
        doc, catalog_rows, assembly_name="Rear_Wall_2_Door",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_rear_wall_90(rear_2, x_offset_ft=wall_module_width_ft * 1.0)
    rear_wall_assemblies.append(rear_2)

    # Module 3: Window (center)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear wall module 3 (window)...\n")
    rear_3 = wa.create_window_wall_double_3x5(
        doc, catalog_rows, assembly_name="Rear_Wall_3_Window",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_rear_wall_90(rear_3, x_offset_ft=wall_module_width_ft * 2.0)
    rear_wall_assemblies.append(rear_3)

    # Module 4: Sliding door (right)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear wall module 4 (door)...\n")
    rear_4 = wa.create_sliding_door_72x80(
        doc, catalog_rows, assembly_name="Rear_Wall_4_Door",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_rear_wall_90(rear_4, x_offset_ft=wall_module_width_ft * 3.0)
    rear_wall_assemblies.append(rear_4)

    # Module 5: Window (far right)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear wall module 5 (window)...\n")
    rear_5 = wa.create_window_wall_double_3x5(
        doc, catalog_rows, assembly_name="Rear_Wall_5_Window",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    rotate_rear_wall_90(rear_5, x_offset_ft=wall_module_width_ft * 4.0)
    rear_wall_assemblies.append(rear_5)

    # Create Rear_Wall group
    rear_wall_grp = bc.create_group(doc, "Rear_Wall")
    bc.add_to_group(rear_wall_grp, rear_wall_assemblies)

    App.Console.PrintMessage(f"[Build_950Surf] Rear wall complete ({len(rear_wall_assemblies)} modules).\n")

    # Add front and rear walls to First_Floor parent group
    bc.add_to_group(first_floor_parent, [front_wall_grp, rear_wall_grp])
    App.Console.PrintMessage("[Build_950Surf] Front and rear walls organized under First_Floor.\n")

# ============================================================
# SECTION 8B: SIDE WALLS (left/west and right/east)
# ============================================================
# FRAMING APPROACH: Front/rear walls are BUTT walls, side walls are THROUGH walls
#   - Front/rear walls run full width (40') at sheathing edges
#   - Side walls run north-south, fitting BETWEEN front and rear walls
#   - This provides continuous structural plates on the side walls for load transfer
#
# Side walls run north-south (along Y axis) from front wall to rear wall
# Floor depth is 48' (3 rows × 16')
# Side walls sit ON the sheathing (inside the front/rear walls) using corner alignment:
#   - Front module: 16' (192"), starts inside front wall
#   - Center module: 185" (16' minus 7" for wall overlap at corners)
#   - Rear module: 16' (192"), ends inside rear wall

if BUILD.get("include_walls", False):
    App.Console.PrintMessage("[Build_950Surf] Building side walls...\n")

    # Side wall positioning using corner alignment
    wall_thickness_in = WALLS["wall_thickness_in"]  # 3.5"
    wall_thickness_ft = wall_thickness_in / 12.0

    # Module lengths
    full_module_length_in = 192.0  # 16' = 192"
    center_module_length_in = 185.0  # 16' - 7" = 185" (3.5" overlap at each end)

    # X positions: walls sit ON sheathing (moved inward by wall thickness)
    # Left wall: west edge of wall aligns with west edge of sheathing
    left_wall_x_ft = sheathing_x_start_ft
    # Right wall: east edge of wall aligns with east edge of sheathing
    right_wall_x_ft = sheathing_x_start_ft + sheathing_width_ft - wall_thickness_ft

    # Y positions: walls fit INSIDE front/rear walls (corner alignment)
    # Front module starts inside front wall (at front wall's inside face)
    side_wall_y_start_ft = sheathing_y_start_ft + wall_thickness_ft

    # === LEFT (WEST) WALL ===
    App.Console.PrintMessage("[Build_950Surf]   Building left (west) side wall...\n")
    left_wall_assemblies = []

    # Module 1: Front (south) 16' section - starts inside front wall
    App.Console.PrintMessage("[Build_950Surf]     Creating left wall module 1 (16' solid stud)...\n")
    left_wall_1 = wa.create_solid_stud_wall_16ft(
        doc, catalog_rows, assembly_name="Left_Wall_1_Solid",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    # No rotation needed - wall is already oriented Y=length (north-south)
    # Position: X at left wall position, Y at front, Z at wall base
    left_wall_1.Placement.Base = App.Vector(
        bc.ft(left_wall_x_ft),
        bc.ft(side_wall_y_start_ft),
        bc.inch(wall_z_base_in)
    )
    left_wall_assemblies.append(left_wall_1)

    # Module 2: Center section - 185" (reduced from 16' to fit between modules)
    # Y position: starts after front module (16' = 192")
    module_2_y_start_ft = side_wall_y_start_ft + (full_module_length_in / 12.0)
    App.Console.PrintMessage("[Build_950Surf]     Creating left wall module 2 (185\" solid stud)...\n")
    left_wall_2 = wa.create_solid_stud_wall(
        doc, catalog_rows, wall_length_in=center_module_length_in,
        assembly_name="Left_Wall_2_Solid",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    left_wall_2.Placement.Base = App.Vector(
        bc.ft(left_wall_x_ft),
        bc.ft(module_2_y_start_ft),
        bc.inch(wall_z_base_in)
    )
    left_wall_assemblies.append(left_wall_2)

    # Module 3: Rear (north) 16' section - ends inside rear wall
    # Y position: starts after center module (192" + 185" = 377")
    module_3_y_start_ft = module_2_y_start_ft + (center_module_length_in / 12.0)
    App.Console.PrintMessage("[Build_950Surf]     Creating left wall module 3 (16' solid stud)...\n")
    left_wall_3 = wa.create_solid_stud_wall_16ft(
        doc, catalog_rows, assembly_name="Left_Wall_3_Solid",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    left_wall_3.Placement.Base = App.Vector(
        bc.ft(left_wall_x_ft),
        bc.ft(module_3_y_start_ft),
        bc.inch(wall_z_base_in)
    )
    left_wall_assemblies.append(left_wall_3)

    # Create Left_Wall group
    left_wall_grp = bc.create_group(doc, "Left_Wall")
    bc.add_to_group(left_wall_grp, left_wall_assemblies)
    App.Console.PrintMessage(f"[Build_950Surf]   Left wall complete ({len(left_wall_assemblies)} modules).\n")

    # === RIGHT (EAST) WALL ===
    App.Console.PrintMessage("[Build_950Surf]   Building right (east) side wall...\n")
    right_wall_assemblies = []

    # Module 1: Front (south) 16' section - starts inside front wall
    App.Console.PrintMessage("[Build_950Surf]     Creating right wall module 1 (16' solid stud)...\n")
    right_wall_1 = wa.create_solid_stud_wall_16ft(
        doc, catalog_rows, assembly_name="Right_Wall_1_Solid",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    right_wall_1.Placement.Base = App.Vector(
        bc.ft(right_wall_x_ft),
        bc.ft(side_wall_y_start_ft),
        bc.inch(wall_z_base_in)
    )
    right_wall_assemblies.append(right_wall_1)

    # Module 2: Center section - 185" (reduced from 16' to fit between modules)
    # Y position: same as left wall module 2
    App.Console.PrintMessage("[Build_950Surf]     Creating right wall module 2 (185\" solid stud)...\n")
    right_wall_2 = wa.create_solid_stud_wall(
        doc, catalog_rows, wall_length_in=center_module_length_in,
        assembly_name="Right_Wall_2_Solid",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    right_wall_2.Placement.Base = App.Vector(
        bc.ft(right_wall_x_ft),
        bc.ft(module_2_y_start_ft),
        bc.inch(wall_z_base_in)
    )
    right_wall_assemblies.append(right_wall_2)

    # Module 3: Rear (north) 16' section - ends inside rear wall
    # Y position: same as left wall module 3
    App.Console.PrintMessage("[Build_950Surf]     Creating right wall module 3 (16' solid stud)...\n")
    right_wall_3 = wa.create_solid_stud_wall_16ft(
        doc, catalog_rows, assembly_name="Right_Wall_3_Solid",
        x_base=0.0, y_base=0.0, z_base=0.0,
        make_pressure_treated=False, use_debug_colors=False,
    )
    right_wall_3.Placement.Base = App.Vector(
        bc.ft(right_wall_x_ft),
        bc.ft(module_3_y_start_ft),
        bc.inch(wall_z_base_in)
    )
    right_wall_assemblies.append(right_wall_3)

    # Create Right_Wall group
    right_wall_grp = bc.create_group(doc, "Right_Wall")
    bc.add_to_group(right_wall_grp, right_wall_assemblies)
    App.Console.PrintMessage(f"[Build_950Surf]   Right wall complete ({len(right_wall_assemblies)} modules).\n")

    # Add side walls to First_Floor parent group
    bc.add_to_group(first_floor_parent, [left_wall_grp, right_wall_grp])
    App.Console.PrintMessage("[Build_950Surf] Side walls organized under First_Floor.\n")

# ============================================================
# SECTION 9: DECK SURFACE (boards and posts, installed AFTER walls)
# ============================================================

if BUILD.get("include_deck_surface", False):
    App.Console.PrintMessage("[Build_950Surf] Building deck surface (boards, no posts)...\n")

    deck_surface_assemblies = []

    # Front deck surface (3 modules using config dimensions)
    # Only outermost modules get edge boards
    App.Console.PrintMessage("[Build_950Surf]   Creating front deck surface (3 modules from config)...\n")
    front_deck_surface_left = da.create_deck_surface_16x8(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Surface_Left",
        x_base=deck_left_x_ft * 12.0,
        y_base=front_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=True,   # Outermost left edge
        include_right_edge=False,  # Interior edge
    )
    deck_surface_assemblies.append(front_deck_surface_left)

    front_deck_surface_center = da.create_deck_surface_8ft9in_x_8ft(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Surface_Center",
        x_base=(deck_left_x_ft + module_16_width_ft) * 12.0,
        y_base=front_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=False,  # Interior (no edge boards on center module)
        include_right_edge=False,
    )
    # Snap center surface to left surface (matches joist snapping)
    lc.snap_assembly_corner_to_corner(
        front_deck_surface_center, front_deck_surface_left, target_corner="bottom_right", assembly_corner="bottom_left"
    )
    deck_surface_assemblies.append(front_deck_surface_center)

    front_deck_surface_right = da.create_deck_surface_16x8(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Surface_Right",
        x_base=(deck_left_x_ft + module_16_width_ft + center_module_width_ft) * 12.0,
        y_base=front_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=False,  # Interior edge
        include_right_edge=True,   # Outermost right edge
    )
    # Snap right surface to center surface (matches joist snapping)
    lc.snap_assembly_corner_to_corner(
        front_deck_surface_right, front_deck_surface_center, target_corner="bottom_right", assembly_corner="bottom_left"
    )
    deck_surface_assemblies.append(front_deck_surface_right)

    # Rear deck surface (3 modules using config dimensions)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear deck surface (3 modules from config)...\n")
    rear_deck_surface_left = da.create_deck_surface_16x8(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Surface_Left",
        x_base=deck_left_x_ft * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=True,   # Outermost left edge
        include_right_edge=False,  # Interior edge
    )
    deck_surface_assemblies.append(rear_deck_surface_left)

    rear_deck_surface_center = da.create_deck_surface_8ft9in_x_8ft(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Surface_Center",
        x_base=(deck_left_x_ft + module_16_width_ft) * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=False,  # Interior (no edge boards on center module)
        include_right_edge=False,
    )
    # Snap center surface to left surface (matches joist snapping)
    lc.snap_assembly_corner_to_corner(
        rear_deck_surface_center, rear_deck_surface_left, target_corner="bottom_right", assembly_corner="bottom_left"
    )
    deck_surface_assemblies.append(rear_deck_surface_center)

    rear_deck_surface_right = da.create_deck_surface_16x8(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Surface_Right",
        x_base=(deck_left_x_ft + module_16_width_ft + center_module_width_ft) * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=False,  # Interior edge
        include_right_edge=True,   # Outermost right edge
    )
    # Snap right surface to center surface (matches joist snapping)
    lc.snap_assembly_corner_to_corner(
        rear_deck_surface_right, rear_deck_surface_center, target_corner="bottom_right", assembly_corner="bottom_left"
    )
    deck_surface_assemblies.append(rear_deck_surface_right)

    # Perpendicular deck boards over stair opening (running north-south)
    # Position: stair rim east face (pile east face = 41.46875')
    App.Console.PrintMessage("[Build_950Surf]   Creating perpendicular deck boards over stair opening...\n")
    stair_rim_east_face_x_ft = 41.0 + (11.25 / 24.0)  # Pile_41_28 east face = 41.46875'
    stair_y_snap_ft = STAIRS["stair_y_snap_ft"]  # Top tread south edge position
    stair_deck_surface_perpendicular = da.create_deck_surface_perpendicular_over_stair(
        doc,
        catalog_rows,
        assembly_name="Deck_Surface_Stair_Perpendicular",
        stair_config=STAIRS,
        x_base=stair_rim_east_face_x_ft * 12.0,  # Position at stair rim east face
        y_base=stair_y_snap_ft * 12.0,  # Y position where boards start (front rim north edge)
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    deck_surface_assemblies.append(stair_deck_surface_perpendicular)

    # TODO: Add perpendicular deck boards on ~4' overhangs (left and right of walls)

    # Create Deck_Surface group
    deck_surface_grp = bc.create_group(doc, "Deck_Surface")
    bc.add_to_group(deck_surface_grp, deck_surface_assemblies)

    App.Console.PrintMessage(f"[Build_950Surf] Deck surface complete ({len(deck_surface_assemblies)} modules).\n")
else:
    App.Console.PrintMessage("[Build_950Surf] Deck surface skipped (disabled in BUILD config)\n")

# ============================================================
# FINAL RECOMPUTE
# ============================================================

App.Console.PrintMessage("[Build_950Surf] Recomputing document...\n")
bc.recompute_once(doc)
App.Console.PrintMessage("[Build_950Surf] Build complete!\n")

# ============================================================
# FINALIZE VIEW (show all, hide helpers, fit camera)
# ============================================================

App.Console.PrintMessage("[Build_950Surf] Finalizing view (show model, hide origins/axes)...\n")

# Show all model objects, hide LCS (Local Coordinate System) helpers
for obj in doc.Objects:
    try:
        type_id = obj.TypeId
        is_helper = (
            type_id == "PartDesign::CoordinateSystem"
            or type_id in ["PartDesign::Plane", "App::Plane", "App::Origin", "App::Line", "App::Axis"]
            or "Axis" in obj.Name
            or "Origin" in obj.Name
        )

        # Set visibility (hide helpers, show everything else)
        if hasattr(obj, "Visibility"):
            obj.Visibility = not is_helper
        if hasattr(obj, "ViewObject") and hasattr(obj.ViewObject, "Visibility"):
            obj.ViewObject.Visibility = not is_helper
    except Exception:
        pass

# Set camera view (if GUI available)
try:
    import FreeCADGui as Gui
    if Gui.ActiveDocument:
        v = Gui.ActiveDocument.ActiveView
        v.setCameraType("Orthographic")
        v.viewIsometric()
        v.fitAll()
        App.Console.PrintMessage("[Build_950Surf] Camera set to isometric and fit.\n")
except Exception:
    pass

# ============================================================
# SAVE DOCUMENT (if path specified via environment)
# ============================================================

save_path = os.environ.get("LUMBER_SAVE_FCSTD")
if save_path:
    try:
        doc.saveAs(save_path)
        App.Console.PrintMessage(f"[Build_950Surf] Saved model to {save_path}\n")
    except Exception as e:
        App.Console.PrintError(f"[Build_950Surf] Failed to save model to {save_path}: {e}\n")
