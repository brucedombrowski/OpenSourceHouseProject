"""Build 950 Surf Beach House - Refactored Version

Construction-grade parametric model for 950 Surf Ave beach house.

Architecture:
    - Foundation: 30 pilings (5x6 grid) with double beams and blocking
    - Floor: Two 16x16 joist modules with sheathing
    - Walls: 2x4 framing with window/door openings
    - Stairs: Interior/exterior access
    - Second Floor: Mirrors first floor layout
    - Roof: Gable + shed configurations

Build Sequence (matches group hierarchy):
    1. Lot survey lines
    2. Foundation (piles, beams, blocking)
    3. First floor joists + sheathing
    4. First floor walls
    5. Second floor joists + sheathing
    6. Second floor walls
    7. Stairs
    8. Roofing

Usage:
    Run this macro in FreeCAD. It will generate the complete house model
    and export BOM to beach_bom.csv.

Author: OpenSourceHouseProject
Dedication: For Luke Dombrowski. Stay Alive.
"""

import FreeCAD as App
import Part
import os
import sys

# Import BeachHouse helpers and config
# Use absolute paths to work when macro is copied to builds/ folder
_this_file = __file__ if __file__ else os.getcwd()
_design_house_root = os.path.dirname(os.path.abspath(_this_file))

# If this macro is in builds/, go up one level to find DesignHouse root
if os.path.basename(_design_house_root) == "builds":
    _design_house_root = os.path.dirname(_design_house_root)

_macros_dir = os.path.join(_design_house_root, "macros")

if _macros_dir not in sys.path:
    sys.path.append(_macros_dir)
if _design_house_root not in sys.path:
    sys.path.append(_design_house_root)

try:
    import beach_common as bc
    BEACH_COMMON_AVAILABLE = True
except ImportError:
    App.Console.PrintError(
        "[Build_950Surf] beach_common.py not found; cannot proceed.\n"
        "Ensure beach_common.py exists in macros/ directory.\n"
    )
    raise

# Import design configuration
try:
    from config_950_surf import LOT, FOUNDATION, FIRST_FLOOR, BUILD
    App.Console.PrintMessage("[Build_950Surf] Loaded design configuration from 950_surf_config.py\n")
except ImportError:
    App.Console.PrintError(
        "[Build_950Surf] 950_surf_config.py not found; using default parameters.\n"
    )
    # Fallback defaults
    LOT = {"width_ft": 75.0, "depth_ft": 100.0, "front_setback_ft": 20.0, "side_setback_ft": 7.5}
    FOUNDATION = {
        "pile_grid_x": 5, "pile_grid_y": 6, "pile_spacing_x_ft": 8.0, "pile_spacing_y_ft": 8.0,
        "above_grade_ft": 20.0, "pile_size_in": 12.0, "pile_length_ft": 40.0
    }
    FIRST_FLOOR = {"start_x_ft": 9.0, "start_y_ft": 20.0, "base_z_ft": 20.0}
    BUILD = {"include_lot_survey": True, "include_foundation": True, "include_first_floor": True}

# ============================================================
# EXTRACT PARAMETERS FROM CONFIG
# ============================================================

# Lot geometry
lot_x_ft = LOT["width_ft"]
lot_y_ft = LOT["depth_ft"]
side_setback_ft = LOT["side_setback_ft"]
front_setback_ft = LOT["front_setback_ft"]

# Foundation
pile_label = "12x12x40_piling_PT"
embed_depth_ft = 20.0      # Below grade
above_grade_ft = FOUNDATION["above_grade_ft"]
pile_base_z_in = -embed_depth_ft * 12.0

# Pile grid
num_piles_x = FOUNDATION["pile_grid_x"]
num_piles_y = FOUNDATION["pile_grid_y"]
x_spacing_ft = FOUNDATION["pile_spacing_x_ft"]
y_spacing_ft = FOUNDATION["pile_spacing_y_ft"]

# Calculate pile positions for 6x6 grid
# Center the pile grid on the lot (X direction)
# Total span: 5 gaps × 8' = 40'
total_pile_span_x_ft = (num_piles_x - 1) * x_spacing_ft
pile_start_x_ft = (lot_x_ft - total_pile_span_x_ft) / 2.0
x_positions_ft = [pile_start_x_ft + i * x_spacing_ft for i in range(num_piles_x)]

# Y positions: front pile face at front setback
# Note: Shift center by half pile thickness so face aligns with setback
pile_thickness_ft = 11.25 / 12.0  # 12x12 pile thickness in feet
start_y_ft = front_setback_ft + (pile_thickness_ft / 2.0)
y_positions_ft = [start_y_ft + i * y_spacing_ft for i in range(num_piles_y)]

# Beam parameters (2x12x16 PT, running along Y, double-beam config)
beam_label = "beam_2x12x192_PT"
beam_row_step = 3          # Every 3rd row gets beams (spans 24' with 16' beam)
beam_gap_in = 0.0          # Gap between double beams (0 = tight to pile faces)

# Blocking parameters (between double beams, provides lateral support per IRC R502.7)
blocking_offsets_ft = [4.0, 12.0]  # Positions along 16' beam (4' and 12' from start)

# Mid-span boards (8' boards between specific rows for additional support)
mid_board_label = "beam_2x12x96_PT"
mid_board_offset_L_in = 1.5        # Left side offset
mid_board_offset_R_in = -(1.5 * 2.0)  # Right side offset

# Joist module parameters (16x16 modules, 2x12 @ 16" OC)
module_x_ft = 16.0
module_y_ft = 16.0
module_joist_label = "joist_2x12_PT"
module_first_spacing_in = 14.5     # Front rim to first joist
module_joist_spacing_in = 16.0     # Remaining joists at 16" OC
module_left_x_ft = lot_x_ft / 2.0  # Align to lot centerline
module_front_y_ft = front_setback_ft
module_base_z_ft = above_grade_ft

# Sheathing parameters
sheathing_thick_in = 0.75
sheathing_label = "panel_advantech_4x8"

# Hanger parameters (Simpson LU210 approximation)
hanger_label = "hanger_LU210"
hanger_thickness_in = 0.06
hanger_height_in = 7.8125
hanger_seat_depth_in = 2.0
hanger_color = None

# ============================================================
# CATALOG LOADING
# ============================================================

App.Console.PrintMessage("[Build_950Surf] Loading catalogs...\n")
catalog = bc.load_beach_catalog()
bc.print_catalog_summary(catalog)

# ============================================================
# DOCUMENT SETUP
# ============================================================

doc = App.newDocument("950Surf")
App.Console.PrintMessage("[Build_950Surf] Created document: 950Surf\n")

# ============================================================
# SECTION 1: LOT SURVEY (Boundary + Buildable Area + Origin)
# ============================================================

def create_lot_survey(doc, lot_x_ft, lot_y_ft, front_setback_ft, side_setback_ft):
    """Create lot survey boundary, buildable area, and origin marker.

    Construction Notes:
        - Lot boundary shows property lines (legal survey)
        - Buildable area shows zoning envelope (setbacks applied)
        - Origin marker at (0,0) for reference

    Args:
        doc: FreeCAD document
        lot_x_ft: Lot width in feet
        lot_y_ft: Lot depth in feet
        front_setback_ft: Front setback per zoning
        side_setback_ft: Side setback per zoning

    Returns:
        lot_grp: DocumentObjectGroup containing lot geometry
    """
    App.Console.PrintMessage("[Build_950Surf] Creating lot survey...\n")

    # Lot boundary (property lines)
    lot_pts = [
        App.Vector(0, 0, 0),
        App.Vector(bc.ft(lot_x_ft), 0, 0),
        App.Vector(bc.ft(lot_x_ft), bc.ft(lot_y_ft), 0),
        App.Vector(0, bc.ft(lot_y_ft), 0),
        App.Vector(0, 0, 0),  # Close polygon
    ]
    lot_wire = Part.makePolygon(lot_pts)
    lot_obj = doc.addObject("Part::Feature", "Lot_Boundary")
    lot_obj.Shape = lot_wire

    # Buildable area (zoning envelope)
    buildable_pts = [
        App.Vector(bc.ft(side_setback_ft), bc.ft(front_setback_ft), 0),
        App.Vector(bc.ft(lot_x_ft - side_setback_ft), bc.ft(front_setback_ft), 0),
        App.Vector(bc.ft(lot_x_ft - side_setback_ft), bc.ft(lot_y_ft), 0),
        App.Vector(bc.ft(side_setback_ft), bc.ft(lot_y_ft), 0),
        App.Vector(bc.ft(side_setback_ft), bc.ft(front_setback_ft), 0),
    ]
    buildable_wire = Part.makePolygon(buildable_pts)
    buildable_obj = doc.addObject("Part::Feature", "Buildable_Area")
    buildable_obj.Shape = buildable_wire

    # Origin marker (cross at 0,0)
    cross_lines = [
        Part.makeLine(App.Vector(-bc.ft(1.0), 0, 0), App.Vector(bc.ft(1.0), 0, 0)),
        Part.makeLine(App.Vector(0, -bc.ft(1.0), 0), App.Vector(0, bc.ft(1.0), 0)),
    ]
    cross_obj = doc.addObject("Part::Feature", "Origin_Marker")
    cross_obj.Shape = Part.Compound(cross_lines)

    # Group lot objects
    lot_grp = bc.create_group(doc, "Lot")
    bc.add_to_group(lot_grp, [lot_obj, buildable_obj, cross_obj])

    App.Console.PrintMessage("[Build_950Surf] Lot survey complete.\n")
    return lot_grp

# Create lot survey
lot_grp = create_lot_survey(doc, lot_x_ft, lot_y_ft, front_setback_ft, side_setback_ft)

# ============================================================
# SECTION 2: FOUNDATION (Piles, Beams, Blocking, Mid-Boards)
# ============================================================

def create_foundation(doc, catalog, params):
    """Build pile foundation with double beams, blocking, and mid-span boards.

    Construction Sequence:
        1. Install pilings (30 ea, 12x12x40 PT, embedded 20' below grade)
        2. Install double beams on pile caps (2x12x16 PT, both sides of pile)
        3. Install blocking between beams at 4' and 12' (lateral support per IRC R502.7)
        4. Install mid-span boards between specific rows (additional load distribution)
        5. Notch piles for beam seats (boolean cut operation)

    Design Rationale:
        - Pile grid: 5x6 = 30 piles @ 8' OC (matches joist module spacing)
        - Embed depth: 20' below grade (local code + storm surge + safety factor)
        - Above grade: 20' (elevated above max flood elevation per FEMA)
        - Double beams: Both sides of pile provide redundant load paths
        - Blocking: IRC R502.7 requires lateral bracing at mid-span
        - Beam span: 16' beam centered on 3 piles = 24' coverage

    Args:
        doc: FreeCAD document
        catalog: Catalog rows from beach_common
        params (dict): Foundation parameters with keys:
            - pile_label, x_positions_ft, y_positions_ft, pile_base_z_in, pile_height_in
            - beam_label, beam_row_step, beam_gap_in, blocking_offsets_ft
            - mid_board_label, mid_board_offset_L_in, mid_board_offset_R_in

    Returns:
        foundation_grp: DocumentObjectGroup with subgroups:
            - Piles (30 ea)
            - Beams (double beams per pile row)
            - Blocking (lateral bracing)
            - MidBoards (mid-span support)

    Raises:
        ValueError: If pile_label or beam_label not found in catalog
    """
    App.Console.PrintMessage("[Build_950Surf] Building foundation...\n")

    # Lookup catalog entries (fail-fast if not found)
    pile_row = bc.find_stock(catalog, params["pile_label"])
    beam_row = bc.find_stock(catalog, params["beam_label"])
    mid_board_row = bc.find_stock(catalog, params["mid_board_label"])

    # Extract dimensions from catalog
    pile_width_in = float(pile_row["actual_width_in"])
    pile_thick_in = float(pile_row["actual_thickness_in"])
    pile_len_in = float(pile_row["length_in"])

    beam_thick_in = float(beam_row["actual_thickness_in"])
    beam_depth_in = float(beam_row["actual_width_in"])
    beam_len_in = float(beam_row["length_in"])

    mid_thick_in = float(mid_board_row["actual_thickness_in"])
    mid_depth_in = float(mid_board_row["actual_width_in"])
    mid_len_in = float(mid_board_row["length_in"])

    # Calculate Z positions
    pile_height_in = params["pile_height_in"]
    beam_top_z_in = params["pile_base_z_in"] + pile_len_in
    beam_base_z_in = beam_top_z_in - beam_depth_in

    # === CREATE PILES ===
    App.Console.PrintMessage("[Build_950Surf]   Creating piles...\n")
    pile_objs = []
    for xi_ft in params["x_positions_ft"]:
        for yi_ft in params["y_positions_ft"]:
            name = f"Pile_{int(xi_ft)}_{int(yi_ft)}"
            pile = bc.make_pile(
                doc, catalog, params["pile_label"], name,
                xi_ft, yi_ft, params["pile_base_z_in"], pile_height_in
            )
            pile_objs.append(pile)

    App.Console.PrintMessage(f"[Build_950Surf]   Created {len(pile_objs)} piles.\n")

    # === CREATE BEAMS ===
    App.Console.PrintMessage("[Build_950Surf]   Creating beams...\n")
    beam_objs = []
    for xi_ft in params["x_positions_ft"]:
        # Beams every 3rd row (covers 3 rows with 16' beam)
        rows = list(range(0, max(0, len(params["y_positions_ft"]) - 2), params["beam_row_step"]))
        for r in rows:
            y_center_ft = params["y_positions_ft"][r + 1]  # Middle row of trio

            # Left beam (notched into left side of pile)
            # Left face of beam aligns with left face of pile
            # Note: make_beam() centers the beam on x_ft, so add beam_thick/2 to get left face alignment
            base_x_left_in = (xi_ft * 12.0) - (pile_width_in / 2.0) + (beam_thick_in / 2.0)
            name_L = f"Beam_{int(xi_ft)}_{r}_L"
            beam_L = bc.make_beam(
                doc, catalog, params["beam_label"], name_L,
                base_x_left_in / 12.0, y_center_ft - (beam_len_in / 12.0 / 2.0),
                beam_base_z_in, beam_len_in, orientation="Y"
            )
            beam_objs.append(beam_L)

            # Right beam (notched into right side of pile)
            # Right face of beam aligns with right face of pile
            # Note: make_beam() centers the beam on x_ft, so add beam_thick/2 to get right face alignment
            base_x_right_in = (xi_ft * 12.0) + (pile_width_in / 2.0) - (beam_thick_in / 2.0)
            name_R = f"Beam_{int(xi_ft)}_{r}_R"
            beam_R = bc.make_beam(
                doc, catalog, params["beam_label"], name_R,
                base_x_right_in / 12.0, y_center_ft - (beam_len_in / 12.0 / 2.0),
                beam_base_z_in, beam_len_in, orientation="Y"
            )
            beam_objs.append(beam_R)

    App.Console.PrintMessage(f"[Build_950Surf]   Created {len(beam_objs)} beams.\n")

    # === NOTCH PILES FOR BEAMS ===
    App.Console.PrintMessage("[Build_950Surf]   Notching piles for beam seating...\n")
    # Create notch cutouts for each beam position
    # Notch: beam_thick_in wide (X) × pile_thick_in deep (Y) × beam_depth_in tall (Z)
    notch_count = 0
    for pile in pile_objs:
        pile_bb = pile.Shape.BoundBox

        # Check if any beams intersect this pile in XY plane
        for beam in beam_objs:
            beam_bb = beam.Shape.BoundBox

            # Check if beam's Y range overlaps pile's Y range
            if beam_bb.YMax >= pile_bb.YMin and beam_bb.YMin <= pile_bb.YMax:
                # Create notch box aligned with beam position
                # Notch width (X): beam thickness
                # Notch depth (Y): pile thickness (full depth through pile)
                # Notch height (Z): beam depth
                notch_box = Part.makeBox(
                    bc.inch(beam_thick_in),
                    bc.inch(pile_thick_in),
                    bc.inch(beam_depth_in)
                )
                # Position notch at beam's X position, pile's Y position, beam's Z position
                notch_box.Placement.Base = App.Vector(
                    beam_bb.XMin,
                    pile_bb.YMin,
                    bc.inch(beam_base_z_in)
                )

                # Cut notch from pile
                try:
                    pile.Shape = pile.Shape.cut(notch_box)
                    notch_count += 1
                except Exception as e:
                    App.Console.PrintWarning(f"[Build_950Surf]   Failed to notch {pile.Name}: {e}\n")

    App.Console.PrintMessage(f"[Build_950Surf]   Created {notch_count} pile notches.\n")

    # === GROUP FOUNDATION ===
    foundation_grp = bc.create_group(doc, "Foundation")
    piles_grp = bc.create_group(doc, "Piles")
    beams_grp = bc.create_group(doc, "Beams")

    bc.add_to_group(piles_grp, pile_objs)
    bc.add_to_group(beams_grp, beam_objs)
    bc.add_to_group(foundation_grp, [piles_grp, beams_grp])

    App.Console.PrintMessage("[Build_950Surf] Foundation complete.\n")
    return foundation_grp

# Create foundation
foundation_params = {
    "pile_label": pile_label,
    "x_positions_ft": x_positions_ft,
    "y_positions_ft": y_positions_ft,
    "pile_base_z_in": pile_base_z_in,
    "pile_height_in": above_grade_ft * 12.0 - pile_base_z_in,
    "beam_label": beam_label,
    "beam_row_step": beam_row_step,
    "beam_gap_in": beam_gap_in,
    "blocking_offsets_ft": blocking_offsets_ft,
    "mid_board_label": mid_board_label,
    "mid_board_offset_L_in": mid_board_offset_L_in,
    "mid_board_offset_R_in": mid_board_offset_R_in,
}

foundation_grp = create_foundation(doc, catalog, foundation_params)

# ============================================================
# SECTION 3: FIRST FLOOR JOISTS (Assembly-Based Modules)
# ============================================================

def create_first_floor_joists(doc, catalog, params, macro_dir):
    """Build first floor using reusable joist module assemblies with snapping.

    Construction Sequence:
        1. Load joist module macros (16x16, 16x8 assemblies)
        2. Create module instances and position via snapping
        3. NO hard-coded offsets - uses bounding box geometry

    Design Rationale:
        - Reusable modules eliminate code duplication
        - Assembly snapping ensures perfect alignment (0.0000mm gaps)
        - Clean hierarchy: Floor → Module (assembly) → Joists + Hardware

    Floor Layout (simplified proof-of-concept):
        - Front row: Two 16x16 modules side-by-side (32' x 16')
        - This demonstrates assembly snapping with no magic numbers

    Args:
        doc: FreeCAD document
        catalog: Catalog rows from beach_common
        params (dict): Floor parameters with keys:
            - floor_base_z_ft: Z position for floor deck
            - floor_start_x_ft, floor_start_y_ft: Front-left corner position
        macro_dir: Path to this macro's directory

    Returns:
        floor_grp: DocumentObjectGroup containing floor assemblies
    """
    import codecs
    import importlib

    App.Console.PrintMessage("[Build_950Surf] Building first floor joists (assembly-based)...\n")

    # Import lumber modules
    # macro_dir might be empty when running from FreeCADCmd
    if not macro_dir:
        macro_dir = os.getcwd()

    # macro_dir is BeachHouse/macros
    # Need to go: macros -> BeachHouse -> FreeCAD -> lumber
    beachhouse_dir = os.path.dirname(macro_dir)
    freecad_root = os.path.dirname(beachhouse_dir)
    lumber_path = os.path.join(freecad_root, "lumber")
    lumber_path = os.path.abspath(lumber_path)

    if lumber_path not in sys.path:
        sys.path.append(lumber_path)

    import lumber_common as lc
    import parts
    importlib.reload(lc)
    importlib.reload(parts)

    # Load catalog
    catalog_path = os.path.join(lumber_path, "lumber_catalog.csv")
    catalog_rows = lc.load_catalog(catalog_path)
    App.Console.PrintMessage(f"[Build_950Surf]   Loaded {len(catalog_rows)} catalog entries\n")

    modules = []

    # Calculate lot center X position for middle modules (8x16, 8x8, 8x16)
    # Middle modules should have their center at lot center (25' on 50' lot)
    lot_center_x_ft = params["lot_x_ft"] / 2.0  # 25' on 50' lot
    middle_module_width_in = 99.0  # 8' + 2 rims @ 1.5" each = 99"
    middle_module_width_ft = middle_module_width_in / 12.0  # ~8.25'
    middle_start_x_ft = lot_center_x_ft - (middle_module_width_ft / 2.0)  # Center the 8' module on lot

    # ============================================================
    # FRONT ROW (Y=20'): 16x16 + 8x16 + 16x16 = 40' wide × 16' deep
    # ============================================================
    App.Console.PrintMessage("[Build_950Surf]   === FRONT ROW ===\n")

    # Front-Middle 8x16 (START HERE - placed at lot center)
    App.Console.PrintMessage("[Build_950Surf]   Creating Front-Middle 8x16 (at lot center)...\n")
    front_middle = parts.create_joist_module_8x16(
        doc, catalog_rows, assembly_name="Floor_Front_Middle_8x16", make_pressure_treated=False
    )
    lc.place_assembly_at(front_middle, x_ft=middle_start_x_ft, y_ft=params["floor_start_y_ft"], z_ft=params["floor_base_z_ft"])
    modules.append(front_middle)

    # Front-Left 16x16 (snap to LEFT of middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Front-Left 16x16...\n")
    front_left = parts.create_joist_module_16x16(
        doc, catalog_rows, assembly_name="Floor_Front_Left_16x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(front_left, front_middle, target_corner="bottom_left", assembly_corner="bottom_right")
    modules.append(front_left)

    # Front-Right 16x16 (snap to RIGHT of middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Front-Right 16x16...\n")
    front_right = parts.create_joist_module_16x16(
        doc, catalog_rows, assembly_name="Floor_Front_Right_16x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(front_right, front_middle, target_corner="bottom_right", assembly_corner="bottom_left")
    modules.append(front_right)

    # ============================================================
    # MIDDLE ROW (Y=36'): 16x8 + 8x8 + 16x8 = 40' wide × 8' deep
    # ============================================================
    App.Console.PrintMessage("[Build_950Surf]   === MIDDLE ROW ===\n")

    # Middle-Center 8x8 (placed at lot center, behind front-middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Middle-Center 8x8 (at lot center)...\n")
    middle_center = parts.create_joist_module_8x8(
        doc, catalog_rows, assembly_name="Floor_Middle_Center_8x8", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(middle_center, front_middle, target_corner="top_left", assembly_corner="bottom_left")
    modules.append(middle_center)

    # Middle-Left 16x8 (snap to LEFT of center)
    App.Console.PrintMessage("[Build_950Surf]   Creating Middle-Left 16x8...\n")
    middle_left = parts.create_joist_module_16x8(
        doc, catalog_rows, assembly_name="Floor_Middle_Left_16x8", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(middle_left, middle_center, target_corner="bottom_left", assembly_corner="bottom_right")
    modules.append(middle_left)

    # Middle-Right 16x8 (snap to RIGHT of center)
    App.Console.PrintMessage("[Build_950Surf]   Creating Middle-Right 16x8...\n")
    middle_right = parts.create_joist_module_16x8(
        doc, catalog_rows, assembly_name="Floor_Middle_Right_16x8", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(middle_right, middle_center, target_corner="bottom_right", assembly_corner="bottom_left")
    modules.append(middle_right)

    # ============================================================
    # BACK ROW (Y=44'): 16x16 + 8x16 + 16x16 = 40' wide × 16' deep
    # ============================================================
    App.Console.PrintMessage("[Build_950Surf]   === BACK ROW ===\n")

    # Back-Middle 8x16 (placed at lot center, behind middle-center)
    App.Console.PrintMessage("[Build_950Surf]   Creating Back-Middle 8x16 (at lot center)...\n")
    back_middle = parts.create_joist_module_8x16(
        doc, catalog_rows, assembly_name="Floor_Back_Middle_8x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(back_middle, middle_center, target_corner="top_left", assembly_corner="bottom_left")
    modules.append(back_middle)

    # Back-Left 16x16 (snap to LEFT of middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Back-Left 16x16...\n")
    back_left = parts.create_joist_module_16x16(
        doc, catalog_rows, assembly_name="Floor_Back_Left_16x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(back_left, back_middle, target_corner="bottom_left", assembly_corner="bottom_right")
    modules.append(back_left)

    # Back-Right 16x16 (snap to RIGHT of middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Back-Right 16x16...\n")
    back_right = parts.create_joist_module_16x16(
        doc, catalog_rows, assembly_name="Floor_Back_Right_16x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(back_right, back_middle, target_corner="bottom_right", assembly_corner="bottom_left")
    modules.append(back_right)

    # ============================================================
    # GROUP ALL MODULES
    # ============================================================
    floor_grp = bc.create_group(doc, "First_Floor_Joists")
    bc.add_to_group(floor_grp, modules)

    App.Console.PrintMessage(f"[Build_950Surf]   ✓ Created {len(modules)} floor modules\n")
    App.Console.PrintMessage("[Build_950Surf] First floor joists complete.\\n")

    return floor_grp

# Create first floor joists
# Calculate floor start position for 40' x 40' footprint
# Floor layout: 16x16 + 8x16 + 16x16 = 40.75' wide (including rim thicknesses)
# Floor depth: 16' + 8' + 16' = 40' deep
# Center the floor on the 50' lot
# Start at second row of piles (front deck space reserved for future decking)
floor_width_ft = (195.0 + 99.0 + 195.0) / 12.0  # ~40.75'
floor_depth_ft = (192.0 + 96.0 + 192.0) / 12.0  # 40'

floor_params = {
    "floor_base_z_ft": above_grade_ft,
    "floor_start_x_ft": (lot_x_ft - floor_width_ft) / 2.0,  # Center on lot
    "floor_start_y_ft": front_setback_ft + y_spacing_ft,  # Start at second row of piles
    "lot_x_ft": lot_x_ft,  # Pass lot width for center calculation
}

floor_grp = create_first_floor_joists(doc, catalog, floor_params, _macros_dir)

# ============================================================
# FINAL RECOMPUTE
# ============================================================

App.Console.PrintMessage("[Build_950Surf] Recomputing document...\n")
bc.recompute_once(doc)
App.Console.PrintMessage("[Build_950Surf] Build complete!\n")

# ============================================================
# ENSURE ALL OBJECTS VISIBLE (fixes hidden-by-default issue)
# ============================================================

App.Console.PrintMessage("[Build_950Surf] Ensuring all objects visible (except LCS origins, planes, and axes)...\n")
for obj in doc.Objects:
    try:
        type_id = obj.TypeId
        # Hide LCS (Local Coordinate System) origin markers, planes, origins, and axes
        if (type_id == "PartDesign::CoordinateSystem" or
            type_id in ["PartDesign::Plane", "App::Plane", "App::Origin", "App::Line", "App::Axis"] or
            "Axis" in obj.Name or "Origin" in obj.Name):
            if hasattr(obj, "Visibility"):
                obj.Visibility = False
            if hasattr(obj, "ViewObject") and hasattr(obj.ViewObject, "Visibility"):
                obj.ViewObject.Visibility = False
        else:
            # Make everything else visible
            if hasattr(obj, "Visibility"):
                obj.Visibility = True
            if hasattr(obj, "ViewObject") and hasattr(obj.ViewObject, "Visibility"):
                obj.ViewObject.Visibility = True
    except Exception:
        pass

# ============================================================
# SET VIEW (if GUI available)
# ============================================================

try:
    import FreeCADGui as Gui
    if Gui.ActiveDocument:
        v = Gui.ActiveDocument.ActiveView
        v.setCameraType("Orthographic")
        v.viewIsometric()
        v.fitAll()
        App.Console.PrintMessage("[Build_950Surf] View set to isometric.\n")
except Exception:
    pass

# ============================================================
# SAVE DOCUMENT (if path specified via environment)
# ============================================================

save_path = os.environ.get("LUMBER_SAVE_FCSTD")
if save_path:
    try:
        doc.saveAs(save_path)
        App.Console.PrintMessage(f"[Build_950Surf] Saved model to {save_path}\n")
    except Exception as e:
        App.Console.PrintError(f"[Build_950Surf] Failed to save model to {save_path}: {e}\n")
