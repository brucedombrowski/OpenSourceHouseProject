"""Build 950 Surf Beach House - Refactored Version

Construction-grade parametric model for 950 Surf Ave beach house.

Architecture:
    - Foundation: 30 pilings (5x6 grid) with double beams and blocking
    - Floor: Two 16x16 joist modules with sheathing
    - Walls: 2x4 framing with window/door openings
    - Stairs: Interior/exterior access
    - Second Floor: Mirrors first floor layout
    - Roof: Gable + shed configurations

Build Sequence (matches group hierarchy):
    1. Lot survey lines
    2. Foundation (piles, beams, blocking)
    3. First floor joists + sheathing
    4. First floor walls
    5. Second floor joists + sheathing
    6. Second floor walls
    7. Stairs
    8. Roofing

Usage:
    Run this macro in FreeCAD. It will generate the complete house model
    and export BOM to beach_bom.csv.

Author: OpenSourceHouseProject
Dedication: For Luke Dombrowski. Stay Alive.
"""

import FreeCAD as App
import Part
import os
import sys
import importlib

# Import BeachHouse helpers and config
# Use absolute paths to work when macro is copied to builds/ folder
_this_file = __file__ if __file__ else os.getcwd()
_macro_location = os.path.dirname(os.path.abspath(_this_file))

# If this macro is in builds/, navigate to DesignHouse root
# Structure: FreeCAD/DesignHouse/ExampleBeachHouse/builds/macro.FCMacro
# We need to get to: FreeCAD/DesignHouse/
if os.path.basename(_macro_location) == "builds":
    # Go up from builds/ -> ExampleBeachHouse/ -> DesignHouse/
    _design_house_root = os.path.dirname(os.path.dirname(_macro_location))
else:
    # Macro is in DesignHouse/ directly (template location)
    _design_house_root = _macro_location

_macros_dir = os.path.join(_design_house_root, "macros")

if _macros_dir not in sys.path:
    sys.path.append(_macros_dir)
if _design_house_root not in sys.path:
    sys.path.append(_design_house_root)

try:
    import beach_common as bc
    import beam_assemblies as ba
    import septic_utilities as su
    import beach_elevator as be
    BEACH_COMMON_AVAILABLE = True
except ImportError:
    App.Console.PrintError(
        "[Build_950Surf] beach_common.py, beam_assemblies.py, septic_utilities.py, or beach_elevator.py not found; cannot proceed.\n"
        "Ensure all helper modules exist in macros/ directory.\n"
    )
    raise

# Import design configuration
# BEACH_CONFIG env var MUST point to a config file (e.g., "ExampleBeachHouse/config.py")
beach_config_path = os.environ.get("BEACH_CONFIG", "")

if not beach_config_path:
    App.Console.PrintError("[BeachHouse] ERROR: BEACH_CONFIG environment variable not set.\n")
    App.Console.PrintError("[BeachHouse] Please set BEACH_CONFIG to your config file path.\n")
    App.Console.PrintError("[BeachHouse] Example: export BEACH_CONFIG=ExampleBeachHouse/config.py\n")
    raise RuntimeError("BEACH_CONFIG environment variable not set")

# Load config from specified path
try:
    import importlib.util
    spec = importlib.util.spec_from_file_location("beach_config", beach_config_path)
    beach_config = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(beach_config)
    LOT = beach_config.LOT
    FOUNDATION = beach_config.FOUNDATION
    FIRST_FLOOR = beach_config.FIRST_FLOOR
    SEPTIC_SYSTEM = beach_config.SEPTIC_SYSTEM
    UTILITIES = beach_config.UTILITIES
    DECKS = beach_config.DECKS
    DRIVEWAY = beach_config.DRIVEWAY
    ELEVATOR = beach_config.ELEVATOR
    STAIRS = beach_config.STAIRS
    WALLS = beach_config.WALLS
    BUILD = beach_config.BUILD
    App.Console.PrintMessage(f"[BeachHouse] Loaded design configuration from {beach_config_path}\n")
except Exception as e:
    App.Console.PrintError(f"[BeachHouse] Failed to load config from {beach_config_path}: {e}\n")
    raise

# ============================================================
# EXTRACT PARAMETERS FROM CONFIG
# ============================================================

# Lot geometry
lot_x_ft = LOT["width_ft"]
lot_y_ft = LOT["depth_ft"]
front_setback_ft = LOT["front_setback_ft"]  # South side
left_setback_ft = LOT["left_setback_ft"]    # West side
right_setback_ft = LOT["right_setback_ft"]  # East side
rear_setback_ft = LOT["rear_setback_ft"]    # North side

# Foundation
pile_label = "12x12x40_piling_PT"
pile_length_ft = FOUNDATION["pile_length_ft"]
embed_depth_ft = FOUNDATION["pile_embed_depth_ft"]
above_grade_ft = pile_length_ft - embed_depth_ft  # CALCULATED: top of foundation above grade
pile_base_z_in = -embed_depth_ft * 12.0

# Pile grid
num_piles_x = FOUNDATION["pile_grid_x"]
num_piles_y = FOUNDATION["pile_grid_y"]
x_spacing_ft = FOUNDATION["pile_spacing_x_ft"]
y_spacing_ft = FOUNDATION["pile_spacing_y_ft"]

# Calculate pile positions (pile grid centered on lot in X direction)
total_pile_span_x_ft = (num_piles_x - 1) * x_spacing_ft
pile_start_x_ft = (lot_x_ft - total_pile_span_x_ft) / 2.0
x_positions_ft = [pile_start_x_ft + i * x_spacing_ft for i in range(num_piles_x)]

# Y positions: front pile face at front setback
# Shift center by half pile thickness so face aligns with setback
pile_thickness_ft = FOUNDATION["pile_actual_size_in"] / 12.0
start_y_ft = front_setback_ft + (pile_thickness_ft / 2.0)
y_positions_ft = [start_y_ft + i * y_spacing_ft for i in range(num_piles_y)]

# Beam parameters (double-beam assemblies running along Y)
beam_label = "beam_2x12x192_PT"
beam_row_step = FOUNDATION["beam_row_interval"]
beam_gap_in = FOUNDATION["beam_gap_in"]

# Blocking parameters (lateral support per IRC R502.7)
blocking_offsets_ft = FOUNDATION["blocking_offsets_ft"]

# Mid-span boards (additional support between pile rows)
mid_board_label = "beam_2x12x96_PT"
mid_board_offset_L_in = FOUNDATION["mid_board_offset_left_in"]
mid_board_offset_R_in = FOUNDATION["mid_board_offset_right_in"]

# Joist module parameters (from config)
module_x_ft = 16.0
module_y_ft = 16.0
module_joist_label = "joist_2x12_PT"
module_first_spacing_in = FIRST_FLOOR["joist_first_spacing_in"]
module_joist_spacing_in = FIRST_FLOOR["joist_spacing_oc_in"]
module_left_x_ft = lot_x_ft / 2.0  # Align to lot centerline
module_front_y_ft = front_setback_ft
module_base_z_ft = above_grade_ft

# Sheathing parameters
sheathing_thick_in = FIRST_FLOOR["sheathing_thickness_in"]
sheathing_label = FIRST_FLOOR["sheathing_stock"]

# Hanger parameters (from config)
hanger_label = "hanger_LU210"
hanger_thickness_in = FIRST_FLOOR["hanger_thickness_in"]
hanger_height_in = FIRST_FLOOR["hanger_height_in"]
hanger_seat_depth_in = FIRST_FLOOR["hanger_seat_depth_in"]
hanger_color = None

# ============================================================
# CATALOG LOADING
# ============================================================

App.Console.PrintMessage("[Build_950Surf] Loading catalogs...\n")
catalog = bc.load_beach_catalog()
bc.print_catalog_summary(catalog)

# ============================================================
# DOCUMENT SETUP
# ============================================================

doc = App.newDocument("950Surf")
App.Console.PrintMessage("[Build_950Surf] Created document: 950Surf\n")

# ============================================================
# SECTION 1: LOT SURVEY (Boundary + Buildable Area + Origin)
# ============================================================

def create_lot_survey(doc, lot_x_ft, lot_y_ft, front_setback_ft, left_setback_ft, right_setback_ft, rear_setback_ft):
    """Create lot survey boundary, buildable area, and origin marker.

    Construction Notes:
        - Lot boundary shows property lines (legal survey)
        - Buildable area shows zoning envelope (setbacks applied)
        - Origin marker at (0,0) for reference

    Args:
        doc: FreeCAD document
        lot_x_ft: Lot width in feet (X, east-west)
        lot_y_ft: Lot depth in feet (Y, north-south)
        front_setback_ft: Front (south) setback per zoning
        left_setback_ft: Left (west) setback per zoning
        right_setback_ft: Right (east) setback per zoning
        rear_setback_ft: Rear (north) setback per zoning

    Returns:
        lot_grp: DocumentObjectGroup containing lot geometry
    """
    App.Console.PrintMessage("[Build_950Surf] Creating lot survey...\n")

    # Lot boundary (property lines)
    lot_pts = [
        App.Vector(0, 0, 0),
        App.Vector(bc.ft(lot_x_ft), 0, 0),
        App.Vector(bc.ft(lot_x_ft), bc.ft(lot_y_ft), 0),
        App.Vector(0, bc.ft(lot_y_ft), 0),
        App.Vector(0, 0, 0),  # Close polygon
    ]
    lot_wire = Part.makePolygon(lot_pts)
    lot_obj = doc.addObject("Part::Feature", "Lot_Boundary")
    lot_obj.Shape = lot_wire

    # Buildable area (zoning envelope)
    buildable_pts = [
        App.Vector(bc.ft(left_setback_ft), bc.ft(front_setback_ft), 0),
        App.Vector(bc.ft(lot_x_ft - right_setback_ft), bc.ft(front_setback_ft), 0),
        App.Vector(bc.ft(lot_x_ft - right_setback_ft), bc.ft(lot_y_ft - rear_setback_ft), 0),
        App.Vector(bc.ft(left_setback_ft), bc.ft(lot_y_ft - rear_setback_ft), 0),
        App.Vector(bc.ft(left_setback_ft), bc.ft(front_setback_ft), 0),
    ]
    buildable_wire = Part.makePolygon(buildable_pts)
    buildable_obj = doc.addObject("Part::Feature", "Buildable_Area")
    buildable_obj.Shape = buildable_wire

    # Origin marker (cross at 0,0)
    marker_size_ft = LOT.get("origin_marker_size_ft", 1.0)
    cross_lines = [
        Part.makeLine(App.Vector(-bc.ft(marker_size_ft), 0, 0), App.Vector(bc.ft(marker_size_ft), 0, 0)),
        Part.makeLine(App.Vector(0, -bc.ft(marker_size_ft), 0), App.Vector(0, bc.ft(marker_size_ft), 0)),
    ]
    cross_obj = doc.addObject("Part::Feature", "Origin_Marker")
    cross_obj.Shape = Part.Compound(cross_lines)

    # Group lot objects
    lot_grp = bc.create_group(doc, "Lot")
    bc.add_to_group(lot_grp, [lot_obj, buildable_obj, cross_obj])

    App.Console.PrintMessage("[Build_950Surf] Lot survey complete.\n")
    return lot_grp

# Create lot survey
lot_grp = create_lot_survey(doc, lot_x_ft, lot_y_ft, front_setback_ft, left_setback_ft, right_setback_ft, rear_setback_ft)

# ============================================================
# SECTION 2: SEPTIC SYSTEM (if enabled)
# ============================================================

if BUILD.get("include_septic_system", False):
    App.Console.PrintMessage("[Build_950Surf] === SEPTIC SYSTEM ===\n")
    septic_grp = su.create_septic_system(doc, SEPTIC_SYSTEM)
else:
    App.Console.PrintMessage("[Build_950Surf] Septic system skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 3: FOUNDATION (Piles, Beams, Blocking, Mid-Boards)
# ============================================================

def create_foundation(doc, catalog, params):
    """Build pile foundation with double beams, blocking, and mid-span boards.

    Construction Sequence:
        1. Install pilings (30 ea, 12x12x40 PT, embedded 20' below grade)
        2. Install double beams on pile caps (2x12x16 PT, both sides of pile)
        3. Install blocking between beams at 4' and 12' (lateral support per IRC R502.7)
        4. Install mid-span boards between specific rows (additional load distribution)
        5. Notch piles for beam seats (boolean cut operation)

    Design Rationale:
        - Pile grid: 5x6 = 30 piles @ 8' OC (matches joist module spacing)
        - Embed depth: 20' below grade (local code + storm surge + safety factor)
        - Above grade: 20' (elevated above max flood elevation per FEMA)
        - Double beams: Both sides of pile provide redundant load paths
        - Blocking: IRC R502.7 requires lateral bracing at mid-span
        - Beam span: 16' beam centered on 3 piles = 24' coverage

    Args:
        doc: FreeCAD document
        catalog: Catalog rows from beach_common
        params (dict): Foundation parameters with keys:
            - pile_label, x_positions_ft, y_positions_ft, pile_base_z_in, pile_height_in
            - beam_label, beam_row_step, beam_gap_in, blocking_offsets_ft
            - mid_board_label, mid_board_offset_L_in, mid_board_offset_R_in

    Returns:
        foundation_grp: DocumentObjectGroup with subgroups:
            - Piles (30 ea)
            - Beams (double beams per pile row)
            - Blocking (lateral bracing)
            - MidBoards (mid-span support)

    Raises:
        ValueError: If pile_label or beam_label not found in catalog
    """
    App.Console.PrintMessage("[Build_950Surf] Building foundation...\n")

    # Lookup catalog entries (fail-fast if not found)
    pile_row = bc.find_stock(catalog, params["pile_label"])
    beam_row = bc.find_stock(catalog, params["beam_label"])
    mid_board_row = bc.find_stock(catalog, params["mid_board_label"])

    # Extract dimensions from catalog
    pile_width_in = float(pile_row["actual_width_in"])
    pile_thick_in = float(pile_row["actual_thickness_in"])
    pile_len_in = float(pile_row["length_in"])

    beam_thick_in = float(beam_row["actual_thickness_in"])
    beam_depth_in = float(beam_row["actual_width_in"])
    beam_len_in = float(beam_row["length_in"])

    mid_thick_in = float(mid_board_row["actual_thickness_in"])
    mid_depth_in = float(mid_board_row["actual_width_in"])
    mid_len_in = float(mid_board_row["length_in"])

    # Calculate Z positions
    pile_height_in = params["pile_height_in"]
    beam_top_z_in = params["pile_base_z_in"] + pile_len_in
    beam_base_z_in = beam_top_z_in - beam_depth_in

    # === CREATE PILES ===
    App.Console.PrintMessage("[Build_950Surf]   Creating piles...\n")
    pile_objs = []
    for xi_ft in params["x_positions_ft"]:
        for yi_ft in params["y_positions_ft"]:
            name = f"Pile_{int(xi_ft)}_{int(yi_ft)}"
            pile = bc.make_pile(
                doc, catalog, params["pile_label"], name,
                xi_ft, yi_ft, params["pile_base_z_in"], pile_height_in
            )
            pile_objs.append(pile)

    App.Console.PrintMessage(f"[Build_950Surf]   Created {len(pile_objs)} piles.\n")

    # === CREATE DOUBLE BEAM ASSEMBLIES WITH BLOCKING ===
    App.Console.PrintMessage("[Build_950Surf]   Creating double beam assemblies...\n")
    beam_assemblies = []
    beam_objs = []  # Keep track of individual beam objects for notching

    # Available beam lengths (long to short preference)
    beam_16_row = bc.find_stock(catalog, params["beam_label"])
    beam_8_row = bc.find_stock(catalog, params["mid_board_label"])
    beam_16_len_ft = float(beam_16_row["length_in"]) / 12.0
    beam_8_len_ft = float(beam_8_row["length_in"]) / 12.0

    # Global assembly index (increments for every assembly created)
    assembly_idx = 0

    for xi_ft in params["x_positions_ft"]:
        # Create continuous beams from front to back pile
        # Place beams end-to-end starting from first pile
        y_start_ft = params["y_positions_ft"][0]  # Start at first pile
        y_end_ft = params["y_positions_ft"][-1]   # End at last pile
        total_span_ft = y_end_ft - y_start_ft

        # Calculate beam layout: prefer 16' beams, use 8' for remainder
        y_current_ft = y_start_ft

        while y_current_ft < y_end_ft:
            remaining_span_ft = y_end_ft - y_current_ft

            # Choose assembly type: use 16' if it fits, otherwise use 8'
            if remaining_span_ft >= beam_16_len_ft:
                beam_len_ft = beam_16_len_ft
                # Calculate left beam X position
                # Left beam's LEFT FACE aligns with left side of pile
                # Pile center is at xi_ft, pile left edge is at xi_ft - pile_width/2
                # make_beam() centers beam on x_left_beam_ft, so we need:
                # x_left_beam_ft - beam_thick/2 = xi_ft - pile_width/2
                # Therefore: x_left_beam_ft = xi_ft - pile_width/2 + beam_thick/2
                x_left_beam_ft = xi_ft - (pile_width_in / 12.0 / 2.0) + (beam_thick_in / 12.0 / 2.0)
                assembly = ba.create_double_beam_16ft(
                    doc, catalog,
                    x_left_beam_ft, y_current_ft, beam_base_z_in,
                    assembly_idx=assembly_idx,
                    pile_width_in=pile_width_in,
                    pile_y_positions_ft=params["y_positions_ft"]
                )
            else:
                beam_len_ft = beam_8_len_ft
                # Calculate left beam X position (same logic as 16')
                x_left_beam_ft = xi_ft - (pile_width_in / 12.0 / 2.0) + (beam_thick_in / 12.0 / 2.0)
                assembly = ba.create_double_beam_8ft(
                    doc, catalog,
                    x_left_beam_ft, y_current_ft, beam_base_z_in,
                    assembly_idx=assembly_idx,
                    pile_width_in=pile_width_in,
                    pile_y_positions_ft=params["y_positions_ft"]
                )

            beam_assemblies.append(assembly)

            # Extract beam objects from assembly for notching (skip blocking)
            for obj in assembly.Group:
                if "Beam_" in obj.Name:
                    beam_objs.append(obj)

            y_current_ft += beam_len_ft
            assembly_idx += 1

    App.Console.PrintMessage(f"[Build_950Surf]   Created {len(beam_assemblies)} double beam assemblies.\n")

    # === NOTCH PILES FOR BEAMS ===
    App.Console.PrintMessage("[Build_950Surf]   Notching piles for beam seating...\n")
    # Create notch cutouts for each beam position
    # Notch: beam_thick_in wide (X) × pile_thick_in deep (Y) × beam_depth_in tall (Z)
    # Important: Each pile should have exactly 2 notches (left beam + right beam from the same assembly)
    notch_count = 0
    pile_notch_counts = {}  # Track notches per pile for debugging
    for pile in pile_objs:
        pile_bb = pile.Shape.BoundBox
        pile_center_x_mm = (pile_bb.XMin + pile_bb.XMax) / 2.0
        pile_center_y_mm = (pile_bb.YMin + pile_bb.YMax) / 2.0
        pile_notches_this_pile = 0

        # Each pile should only be notched by beams from ONE assembly (the one directly above it)
        # Beams run along Y, so we check:
        #   1. Beam's Y range includes pile center Y
        #   2. Beam's X range overlaps pile X range (beam sits on pile)
        for beam in beam_objs:
            beam_bb = beam.Shape.BoundBox

            # Check if beam's Y range contains pile center
            y_overlap = beam_bb.YMin <= pile_center_y_mm <= beam_bb.YMax

            # Check if beam's X range overlaps pile's X range
            # Beam sits on pile if beam's X overlaps pile's X (within pile width)
            x_overlap = (beam_bb.XMin <= pile_bb.XMax and beam_bb.XMax >= pile_bb.XMin)

            if y_overlap and x_overlap:
                # Create notch box aligned with beam position
                # Notch width (X): beam thickness
                # Notch depth (Y): pile thickness (full depth through pile)
                # Notch height (Z): beam depth
                notch_box = Part.makeBox(
                    bc.inch(beam_thick_in),
                    bc.inch(pile_thick_in),
                    bc.inch(beam_depth_in)
                )
                # Position notch at beam's X position, pile's Y position, beam's Z position
                notch_box.Placement.Base = App.Vector(
                    beam_bb.XMin,
                    pile_bb.YMin,
                    bc.inch(beam_base_z_in)
                )

                # Cut notch from pile
                try:
                    pile.Shape = pile.Shape.cut(notch_box)
                    notch_count += 1
                    pile_notches_this_pile += 1
                except Exception as e:
                    App.Console.PrintWarning(f"[Build_950Surf]   Failed to notch {pile.Name}: {e}\n")

        pile_notch_counts[pile.Name] = pile_notches_this_pile

    App.Console.PrintMessage(f"[Build_950Surf]   Created {notch_count} pile notches.\n")

    # Debug: Check for piles with unexpected notch counts
    piles_with_2_notches = sum(1 for count in pile_notch_counts.values() if count == 2)
    piles_with_more_than_2 = [name for name, count in pile_notch_counts.items() if count > 2]
    if piles_with_more_than_2:
        App.Console.PrintWarning(
            f"[Build_950Surf]   WARNING: {len(piles_with_more_than_2)} piles have >2 notches: {piles_with_more_than_2[:5]}\n"
        )
    App.Console.PrintMessage(f"[Build_950Surf]   {piles_with_2_notches} piles have exactly 2 notches (expected: 40)\n")

    # === GROUP FOUNDATION ===
    foundation_grp = bc.create_group(doc, "Foundation")
    piles_grp = bc.create_group(doc, "Piles")
    beam_assemblies_grp = bc.create_group(doc, "Beam_Assemblies")

    bc.add_to_group(piles_grp, pile_objs)
    bc.add_to_group(beam_assemblies_grp, beam_assemblies)
    bc.add_to_group(foundation_grp, [piles_grp, beam_assemblies_grp])

    App.Console.PrintMessage("[Build_950Surf] Foundation complete.\n")
    return foundation_grp

# Create foundation
foundation_params = {
    "pile_label": pile_label,
    "x_positions_ft": x_positions_ft,
    "y_positions_ft": y_positions_ft,
    "pile_base_z_in": pile_base_z_in,
    "pile_height_in": above_grade_ft * 12.0 - pile_base_z_in,
    "beam_label": beam_label,
    "beam_row_step": beam_row_step,
    "beam_gap_in": beam_gap_in,
    "blocking_offsets_ft": blocking_offsets_ft,
    "mid_board_label": mid_board_label,
    "mid_board_offset_L_in": mid_board_offset_L_in,
    "mid_board_offset_R_in": mid_board_offset_R_in,
}

foundation_grp = create_foundation(doc, catalog, foundation_params)

# ============================================================
# SECTION 4: UTILITIES AND CONCRETE SLAB (if enabled)
# ============================================================

if BUILD.get("include_concrete_slab", BUILD.get("include_utilities", False)):
    App.Console.PrintMessage("[Build_950Surf] === CONCRETE SLAB ===\n")
    # Pass pile positions for slab cutouts (use actual pile size, not nominal)
    pile_positions_ft = [(x, y) for x in x_positions_ft for y in y_positions_ft]
    slab_grp = su.create_concrete_slab_group(
        doc,
        UTILITIES,
        pile_positions_ft=pile_positions_ft,
        pile_size_in=FOUNDATION.get("pile_actual_size_in", FOUNDATION["pile_size_in"])
    )
else:
    App.Console.PrintMessage("[Build_950Surf] Concrete slab skipped (disabled in BUILD config)\n")

if BUILD.get("include_utilities", False):
    App.Console.PrintMessage("[Build_950Surf] === UTILITIES ===\n")
    # Pass STAIRS, FOUNDATION, and LOT configs for foot wash station and pile hose bibs
    utilities_grp = su.create_utilities_group(doc, UTILITIES, stairs_config=STAIRS, foundation_config=FOUNDATION, lot_config=LOT)
else:
    App.Console.PrintMessage("[Build_950Surf] Utilities skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 4.4: DRIVEWAY SLAB (with rebar)
# ============================================================

if BUILD.get("include_driveway", False):
    App.Console.PrintMessage("[Build_950Surf] === DRIVEWAY ===\n")
    # Pass UTILITIES config to create cutouts for water boxes (dependency tracking)
    driveway_grp = su.create_driveway_slab_group(doc, DRIVEWAY, utilities_config=UTILITIES)
else:
    App.Console.PrintMessage("[Build_950Surf] Driveway skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 4.4: BEACH ELEVATOR (open metal lift)
# ============================================================

if BUILD.get("include_elevator", False):
    App.Console.PrintMessage("[Build_950Surf] === BEACH ELEVATOR ===\n")
    elevator_grp = be.create_beach_elevator(doc, ELEVATOR, foundation_config=FOUNDATION)
else:
    App.Console.PrintMessage("[Build_950Surf] Beach elevator skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 4.45: EXTERIOR STAIRS (from slab to floor)
# ============================================================

if BUILD.get("include_stairs", False):
    App.Console.PrintMessage("[Build_950Surf] === EXTERIOR STAIRS ===\n")
    stairs_grp = su.create_exterior_stairs(doc, STAIRS, floor_z_ft=above_grade_ft, slab_z_ft=0.0)
else:
    App.Console.PrintMessage("[Build_950Surf] Exterior stairs skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 4.5: DECK JOISTS (installed BEFORE first floor sheathing)
# ============================================================

if BUILD.get("include_deck_joists", False):
    App.Console.PrintMessage("[Build_950Surf] Building deck joists...\n")

    # Import deck assembly modules (already in sys.path via _macros_dir)
    import lumber_common as lc
    import deck_assemblies as da
    importlib.reload(da)

    # Load catalog for deck assemblies
    catalog_path = os.path.join(_design_house_root, "lumber", "lumber_catalog.csv")
    catalog_rows = lc.load_catalog(catalog_path)

    deck_z_base_in = above_grade_ft * 12.0  # Same level as foundation top

    # Calculate deck positions
    # Front deck: south of front setback, rim offset aligns with front wall
    front_deck_rim_offset_ft = DECKS["front_deck_rim_offset_in"] / 12.0
    front_deck_y_ft = front_setback_ft + y_spacing_ft - DECKS["front_deck_depth_ft"] - front_deck_rim_offset_ft

    # Rear deck: starts at back edge of floor area (calculated from module depths)
    floor_depth_ft = (FIRST_FLOOR["module_16x16_depth_in"] + FIRST_FLOOR["module_16x8_depth_in"] + FIRST_FLOOR["module_16x16_depth_in"]) / 12.0
    rear_deck_y_ft = front_setback_ft + y_spacing_ft + floor_depth_ft

    # Deck X positioning: snap to first floor joists
    # Floor width from module dimensions
    floor_width_ft_local = (FIRST_FLOOR["module_16x16_width_in"] + FIRST_FLOOR["module_8x16_width_in"] + FIRST_FLOOR["module_16x16_width_in"]) / 12.0
    floor_start_x_ft = (lot_x_ft - floor_width_ft_local) / 2.0  # Center floor on lot
    deck_left_x_ft = floor_start_x_ft  # Snap deck left edge to floor left edge

    deck_joist_assemblies = []

    # Front deck joists (3 modules using config dimensions)
    module_16_width_ft = DECKS["module_16_width_in"] / 12.0
    center_module_width_ft = DECKS["center_module_width_in"] / 12.0

    App.Console.PrintMessage("[Build_950Surf]   Creating front deck joists (3 modules from config)...\n")
    front_deck_joists_left = da.create_deck_joists_16x8(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Joists_Left",
        x_base=deck_left_x_ft * 12.0,
        y_base=front_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    deck_joist_assemblies.append(front_deck_joists_left)

    front_deck_joists_center = da.create_deck_joists_8ft9in_x_8ft(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Joists_Center",
        x_base=(deck_left_x_ft + module_16_width_ft) * 12.0,
        y_base=front_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    deck_joist_assemblies.append(front_deck_joists_center)

    front_deck_joists_right = da.create_deck_joists_16x8(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Joists_Right",
        x_base=(deck_left_x_ft + module_16_width_ft + center_module_width_ft) * 12.0,
        y_base=front_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    deck_joist_assemblies.append(front_deck_joists_right)

    # Rear deck joists (3 modules using config dimensions)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear deck joists (3 modules from config)...\n")
    rear_deck_joists_left = da.create_deck_joists_16x8(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Joists_Left",
        x_base=deck_left_x_ft * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    deck_joist_assemblies.append(rear_deck_joists_left)

    rear_deck_joists_center = da.create_deck_joists_8ft9in_x_8ft(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Joists_Center",
        x_base=(deck_left_x_ft + module_16_width_ft) * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    deck_joist_assemblies.append(rear_deck_joists_center)

    rear_deck_joists_right = da.create_deck_joists_16x8(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Joists_Right",
        x_base=(deck_left_x_ft + module_16_width_ft + center_module_width_ft) * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
    )
    deck_joist_assemblies.append(rear_deck_joists_right)

    # Create Deck_Joists group
    deck_joists_grp = bc.create_group(doc, "Deck_Joists")
    bc.add_to_group(deck_joists_grp, deck_joist_assemblies)

    App.Console.PrintMessage(f"[Build_950Surf] Deck joists complete ({len(deck_joist_assemblies)} modules).\n")
else:
    App.Console.PrintMessage("[Build_950Surf] Deck joists skipped (disabled in BUILD config)\n")

# ============================================================
# SECTION 5: FIRST FLOOR JOISTS (Assembly-Based Modules)
# ============================================================

def create_first_floor_joists(doc, catalog, params, macro_dir):
    """Build first floor using reusable joist module assemblies with snapping.

    Construction Sequence:
        1. Load joist module macros (16x16, 16x8 assemblies)
        2. Create module instances and position via snapping
        3. NO hard-coded offsets - uses bounding box geometry

    Design Rationale:
        - Reusable modules eliminate code duplication
        - Assembly snapping ensures perfect alignment (0.0000mm gaps)
        - Clean hierarchy: Floor → Module (assembly) → Joists + Hardware

    Floor Layout (simplified proof-of-concept):
        - Front row: Two 16x16 modules side-by-side (32' x 16')
        - This demonstrates assembly snapping with no magic numbers

    Args:
        doc: FreeCAD document
        catalog: Catalog rows from beach_common
        params (dict): Floor parameters with keys:
            - floor_base_z_ft: Z position for floor deck
            - floor_start_x_ft, floor_start_y_ft: Front-left corner position
        macro_dir: Path to this macro's directory

    Returns:
        floor_grp: DocumentObjectGroup containing floor assemblies
    """
    import codecs
    import importlib

    App.Console.PrintMessage("[Build_950Surf] Building first floor joists (assembly-based)...\n")

    # Import lumber modules
    # macro_dir might be empty when running from FreeCADCmd
    if not macro_dir:
        macro_dir = os.getcwd()

    # Import parts modules (already in sys.path via _macros_dir)
    import lumber_common as lc
    import parts
    importlib.reload(lc)
    importlib.reload(parts)

    # Load catalog (use _design_house_root which is already set correctly)
    catalog_path = os.path.join(_design_house_root, "lumber", "lumber_catalog.csv")
    catalog_rows = lc.load_catalog(catalog_path)
    App.Console.PrintMessage(f"[Build_950Surf]   Loaded {len(catalog_rows)} catalog entries\n")

    modules = []

    # Calculate lot center X position for middle modules
    # Middle modules should have their center at lot center
    lot_center_x_ft = params["lot_x_ft"] / 2.0
    middle_module_width_ft = FIRST_FLOOR["module_8x16_width_in"] / 12.0
    middle_start_x_ft = lot_center_x_ft - (middle_module_width_ft / 2.0)  # Center the module on lot

    # ============================================================
    # FRONT ROW (Y=20'): 16x16 + 8x16 + 16x16 = 40' wide × 16' deep
    # ============================================================
    App.Console.PrintMessage("[Build_950Surf]   === FRONT ROW ===\n")

    # Front-Middle 8x16 (START HERE - placed at lot center)
    App.Console.PrintMessage("[Build_950Surf]   Creating Front-Middle 8x16 (at lot center)...\n")
    front_middle = parts.create_joist_module_8x16(
        doc, catalog_rows, assembly_name="Floor_Front_Middle_8x16", make_pressure_treated=False
    )
    lc.place_assembly_at(front_middle, x_ft=middle_start_x_ft, y_ft=params["floor_start_y_ft"], z_ft=params["floor_base_z_ft"])
    modules.append(front_middle)

    # Front-Left 16x16 (snap to LEFT of middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Front-Left 16x16...\n")
    front_left = parts.create_joist_module_16x16(
        doc, catalog_rows, assembly_name="Floor_Front_Left_16x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(front_left, front_middle, target_corner="bottom_left", assembly_corner="bottom_right")
    modules.append(front_left)

    # Front-Right 16x16 (snap to RIGHT of middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Front-Right 16x16...\n")
    front_right = parts.create_joist_module_16x16(
        doc, catalog_rows, assembly_name="Floor_Front_Right_16x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(front_right, front_middle, target_corner="bottom_right", assembly_corner="bottom_left")
    modules.append(front_right)

    # ============================================================
    # MIDDLE ROW (Y=36'): 16x8 + 8x8 + 16x8 = 40' wide × 8' deep
    # ============================================================
    App.Console.PrintMessage("[Build_950Surf]   === MIDDLE ROW ===\n")

    # Middle-Center 8x8 (placed at lot center, behind front-middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Middle-Center 8x8 (at lot center)...\n")
    middle_center = parts.create_joist_module_8x8(
        doc, catalog_rows, assembly_name="Floor_Middle_Center_8x8", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(middle_center, front_middle, target_corner="top_left", assembly_corner="bottom_left")
    modules.append(middle_center)

    # Middle-Left 16x8 (snap to LEFT of center)
    App.Console.PrintMessage("[Build_950Surf]   Creating Middle-Left 16x8...\n")
    middle_left = parts.create_joist_module_16x8(
        doc, catalog_rows, assembly_name="Floor_Middle_Left_16x8", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(middle_left, middle_center, target_corner="bottom_left", assembly_corner="bottom_right")
    modules.append(middle_left)

    # Middle-Right 16x8 (snap to RIGHT of center)
    App.Console.PrintMessage("[Build_950Surf]   Creating Middle-Right 16x8...\n")
    middle_right = parts.create_joist_module_16x8(
        doc, catalog_rows, assembly_name="Floor_Middle_Right_16x8", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(middle_right, middle_center, target_corner="bottom_right", assembly_corner="bottom_left")
    modules.append(middle_right)

    # ============================================================
    # BACK ROW (Y=44'): 16x16 + 8x16 + 16x16 = 40' wide × 16' deep
    # ============================================================
    App.Console.PrintMessage("[Build_950Surf]   === BACK ROW ===\n")

    # Back-Middle 8x16 (placed at lot center, behind middle-center)
    App.Console.PrintMessage("[Build_950Surf]   Creating Back-Middle 8x16 (at lot center)...\n")
    back_middle = parts.create_joist_module_8x16(
        doc, catalog_rows, assembly_name="Floor_Back_Middle_8x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(back_middle, middle_center, target_corner="top_left", assembly_corner="bottom_left")
    modules.append(back_middle)

    # Back-Left 16x16 (snap to LEFT of middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Back-Left 16x16...\n")
    back_left = parts.create_joist_module_16x16(
        doc, catalog_rows, assembly_name="Floor_Back_Left_16x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(back_left, back_middle, target_corner="bottom_left", assembly_corner="bottom_right")
    modules.append(back_left)

    # Back-Right 16x16 (snap to RIGHT of middle)
    App.Console.PrintMessage("[Build_950Surf]   Creating Back-Right 16x16...\n")
    back_right = parts.create_joist_module_16x16(
        doc, catalog_rows, assembly_name="Floor_Back_Right_16x16", make_pressure_treated=False
    )
    lc.snap_assembly_corner_to_corner(back_right, back_middle, target_corner="bottom_right", assembly_corner="bottom_left")
    modules.append(back_right)

    # ============================================================
    # GROUP ALL MODULES
    # ============================================================
    floor_grp = bc.create_group(doc, "First_Floor_Joists")
    bc.add_to_group(floor_grp, modules)

    App.Console.PrintMessage(f"[Build_950Surf]   ✓ Created {len(modules)} floor modules\n")
    App.Console.PrintMessage("[Build_950Surf] First floor joists complete.\\n")

    return floor_grp

# Create first floor joists
# Calculate floor start position from module dimensions in config
# Floor layout calculated from config module dimensions
floor_width_ft = (FIRST_FLOOR["module_16x16_width_in"] + FIRST_FLOOR["module_8x16_width_in"] + FIRST_FLOOR["module_16x16_width_in"]) / 12.0
floor_depth_ft = (FIRST_FLOOR["module_16x16_depth_in"] + FIRST_FLOOR["module_16x8_depth_in"] + FIRST_FLOOR["module_16x16_depth_in"]) / 12.0

floor_params = {
    "floor_base_z_ft": above_grade_ft,
    "floor_start_x_ft": (lot_x_ft - floor_width_ft) / 2.0,  # Center on lot
    "floor_start_y_ft": front_setback_ft + y_spacing_ft,  # Start at second row of piles
    "lot_x_ft": lot_x_ft,  # Pass lot width for center calculation
}

floor_grp = create_first_floor_joists(doc, catalog, floor_params, _macros_dir)

# ============================================================
# SECTION 5.5: STAIR OPENING (Cut joists for stairs)
# ============================================================

if BUILD.get("include_stairs", False):
    App.Console.PrintMessage("[Build_950Surf] Creating stair opening in floor joists...\n")

    # Get list of joists to remove from config
    joists_to_remove = STAIRS.get("opening_joists_to_remove", [])

    if joists_to_remove:
        # Remove conflicting joists and their hangers
        objects_removed = 0
        for obj_name in joists_to_remove:
            obj = doc.getObject(obj_name)
            if obj:
                App.Console.PrintMessage(f"[Build_950Surf]   Removing {obj_name} for stair opening...\n")
                doc.removeObject(obj_name)
                objects_removed += 1

                # Also remove associated hangers (try both naming conventions)
                hanger_front = doc.getObject(f"{obj_name}_Hanger_Front")
                hanger_back = doc.getObject(f"{obj_name}_Hanger_Back")
                if hanger_front:
                    doc.removeObject(hanger_front.Name)
                    objects_removed += 1
                if hanger_back:
                    doc.removeObject(hanger_back.Name)
                    objects_removed += 1

        App.Console.PrintMessage(f"[Build_950Surf]   Removed {objects_removed} objects for stair opening\n")

        # TODO: Add headers to frame stair opening (double joists on sides)
        # This will be implemented in a future update
    else:
        App.Console.PrintMessage("[Build_950Surf]   No joists specified for removal in stair opening config\n")

# ============================================================
# SECTION 6: FIRST FLOOR SHEATHING
# ============================================================

if BUILD.get("include_first_floor", False):
    App.Console.PrintMessage("[Build_950Surf] Adding first floor sheathing...\n")

    # Import lumber modules for sheathing (already in sys.path via _macros_dir)
    import lumber_common as lc
    import parts
    import importlib
    importlib.reload(lc)
    importlib.reload(parts)

    # Load lumber catalog for sheathing panels
    catalog_path = os.path.join(_design_house_root, "lumber", "lumber_catalog.csv")
    catalog_rows = lc.load_catalog(catalog_path)

    # Create a simple bounding box from known floor layout dimensions
    # Floor is 40.75' x 40' (from params above)
    floor_start_x_mm = bc.ft(floor_params["floor_start_x_ft"])
    floor_start_y_mm = bc.ft(floor_params["floor_start_y_ft"])
    floor_width_mm = bc.ft(floor_width_ft)
    floor_depth_mm = bc.ft(floor_depth_ft)
    joist_depth_in = FIRST_FLOOR["joist_depth_in"]
    floor_z_top_mm = bc.ft(floor_params["floor_base_z_ft"]) + bc.inch(joist_depth_in)  # Top of joists

    # Create a simple bbox-like object
    class SimpleBBox:
        def __init__(self, xmin, ymin, xmax, ymax, zmax):
            self.XMin = xmin
            self.YMin = ymin
            self.XMax = xmax
            self.YMax = ymax
            self.ZMax = zmax
            self.XLength = xmax - xmin
            self.YLength = ymax - ymin

    floor_bbox = SimpleBBox(
        floor_start_x_mm,
        floor_start_y_mm,
        floor_start_x_mm + floor_width_mm,
        floor_start_y_mm + floor_depth_mm,
        floor_z_top_mm
    )

    # Create sheathing panels (exclude deck areas from config)
    deck_exclusion_ft = FIRST_FLOOR["sheathing_deck_exclusion_ft"]
    sheathing_grp = parts.create_sheathing_for_floor(
        doc,
        catalog_rows,
        floor_bbox,
        z_offset_in=0.0,  # Sheathing sits ON TOP of joists
        group_name="First_Floor_Sheathing",
        panel_label=FIRST_FLOOR["sheathing_stock"],
        exclude_left_ft=deck_exclusion_ft,
        exclude_right_ft=deck_exclusion_ft,
    )

    App.Console.PrintMessage("[Build_950Surf] First floor sheathing complete.\n")

    # Create top-level First_Floor group to organize joists and sheathing
    # (walls will be added to this group later)
    first_floor_parent = bc.create_group(doc, "First_Floor")
    bc.add_to_group(first_floor_parent, [floor_grp, sheathing_grp])
    App.Console.PrintMessage("[Build_950Surf] First floor joists and sheathing organized.\n")

# ============================================================
# SECTION 7: WALLS
# ============================================================

if BUILD.get("include_walls", False):
    App.Console.PrintMessage("[Build_950Surf] Building walls...\n")

    # Import wall assembly module
    import wall_assemblies as wa
    importlib.reload(wa)

    # Wall positioning parameters
    # Walls sit on top of floor sheathing
    joist_depth_in = FIRST_FLOOR["joist_depth_in"]
    sheathing_thickness_in = FIRST_FLOOR["sheathing_thickness_in"]
    wall_z_base_in = (floor_params["floor_base_z_ft"] * 12.0) + joist_depth_in + sheathing_thickness_in

    # Front wall: aligned with sheathing, offset from config
    sheathing_x_start_ft = floor_params["floor_start_x_ft"] + deck_exclusion_ft
    sheathing_y_start_ft = floor_params["floor_start_y_ft"]

    # Wall positioning from config
    wall_offset_ft = WALLS["front_wall_offset_from_sheathing_ft"]
    front_wall_x_start_ft = sheathing_x_start_ft + wall_offset_ft
    front_wall_y_ft = sheathing_y_start_ft

    # Wall assemblies are created in default orientation (Y = wall length)
    # Then rotated 90° around Z to run along X (front of house)
    # After rotation: X = wall length (along front), Y = wall thickness (depth into house), Z = vertical

    # Front wall module positions (left to right, 8' each)
    # Module layout: Window | Door | Door | Window
    wall_assemblies = []

    # Get wall module width from config
    wall_module_width_ft = WALLS["wall_module_width_ft"]

    # Helper to rotate wall 90° around Z axis
    def rotate_wall_90(wall, x_offset_ft):
        """Rotate wall 90° CCW around Z axis and snap bottom-left corner to sheathing"""
        # Wall is created at origin with orientation: X=thickness, Y=length, Z=vertical
        # Rotate 90° CCW around Z: new orientation is X=length, Y=thickness, Z=vertical
        wall.Placement.Rotation = App.Rotation(App.Vector(0, 0, 1), 90)

        # Snap bottom-left corner of wall to sheathing
        wall_x_ft = front_wall_x_start_ft + x_offset_ft
        wall_y_ft_corner = front_wall_y_ft

        wall.Placement.Base = App.Vector(
            bc.ft(wall_x_ft),
            bc.ft(wall_y_ft_corner),
            bc.inch(wall_z_base_in)
        )

    # Left module (window wall)
    App.Console.PrintMessage("[Build_950Surf]   Creating front wall left module (window)...\n")
    wall_left = wa.create_window_wall_double_3x5(
        doc,
        catalog_rows,
        assembly_name="Front_Wall_Left",
        x_base=0.0,
        y_base=0.0,
        z_base=0.0,  # Will be positioned after rotation
        make_pressure_treated=False,
        use_debug_colors=False,
    )
    rotate_wall_90(wall_left, x_offset_ft=0.0)
    wall_assemblies.append(wall_left)

    # Left-center module (sliding door)
    App.Console.PrintMessage("[Build_950Surf]   Creating front wall left-center module (door)...\n")
    wall_left_center = wa.create_sliding_door_72x80(
        doc,
        catalog_rows,
        assembly_name="Front_Wall_LeftCenter",
        x_base=0.0,
        y_base=0.0,
        z_base=0.0,
        make_pressure_treated=False,
        use_debug_colors=False,
    )
    rotate_wall_90(wall_left_center, x_offset_ft=wall_module_width_ft)
    wall_assemblies.append(wall_left_center)

    # Right-center module (sliding door)
    App.Console.PrintMessage("[Build_950Surf]   Creating front wall right-center module (door)...\n")
    wall_right_center = wa.create_sliding_door_72x80(
        doc,
        catalog_rows,
        assembly_name="Front_Wall_RightCenter",
        x_base=0.0,
        y_base=0.0,
        z_base=0.0,
        make_pressure_treated=False,
        use_debug_colors=False,
    )
    rotate_wall_90(wall_right_center, x_offset_ft=wall_module_width_ft * 2.0)
    wall_assemblies.append(wall_right_center)

    # Right module (window wall)
    App.Console.PrintMessage("[Build_950Surf]   Creating front wall right module (window)...\n")
    wall_right = wa.create_window_wall_double_3x5(
        doc,
        catalog_rows,
        assembly_name="Front_Wall_Right",
        x_base=0.0,
        y_base=0.0,
        z_base=0.0,
        make_pressure_treated=False,
        use_debug_colors=False,
    )
    rotate_wall_90(wall_right, x_offset_ft=wall_module_width_ft * 3.0)
    wall_assemblies.append(wall_right)

    # Create Front_Wall group to organize all wall assemblies
    front_wall_grp = bc.create_group(doc, "Front_Wall")
    bc.add_to_group(front_wall_grp, wall_assemblies)

    App.Console.PrintMessage(f"[Build_950Surf] Front wall complete ({len(wall_assemblies)} modules).\n")

# ============================================================
# SECTION 8: REAR WALL (mirror of front wall)
# ============================================================

if BUILD.get("include_walls", False):
    App.Console.PrintMessage("[Build_950Surf] Building rear wall...\n")

    # Rear wall positioning: mirror of front wall, at back edge of sheathing
    # Sheathing depth from floor module depths
    sheathing_depth_ft = floor_depth_ft
    rear_wall_x_start_ft = front_wall_x_start_ft
    rear_wall_y_ft = sheathing_y_start_ft + sheathing_depth_ft  # Back edge of sheathing
    rear_wall_assemblies = []

    # Get wall thickness from config
    wall_thickness_in = WALLS["wall_thickness_in"]

    # Helper to rotate and position rear wall
    def rotate_rear_wall_90(wall, x_offset_ft):
        """Rotate wall 90° CCW around Z axis and position at rear of house"""
        wall.Placement.Rotation = App.Rotation(App.Vector(0, 0, 1), 90)

        # Position at rear edge, accounting for wall thickness
        wall_x_ft = rear_wall_x_start_ft + x_offset_ft
        wall_y_ft_corner = rear_wall_y_ft - (wall_thickness_in / 12.0)

        wall.Placement.Base = App.Vector(
            bc.ft(wall_x_ft),
            bc.ft(wall_y_ft_corner),
            bc.inch(wall_z_base_in)
        )

    # Left module (window wall)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear wall left module (window)...\n")
    rear_left = wa.create_window_wall_double_3x5(
        doc,
        catalog_rows,
        assembly_name="Rear_Wall_Left",
        x_base=0.0,
        y_base=0.0,
        z_base=0.0,
        make_pressure_treated=False,
        use_debug_colors=False,
    )
    rotate_rear_wall_90(rear_left, x_offset_ft=0.0)
    rear_wall_assemblies.append(rear_left)

    # Left-center module (sliding door)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear wall left-center module (door)...\n")
    rear_left_center = wa.create_sliding_door_72x80(
        doc,
        catalog_rows,
        assembly_name="Rear_Wall_LeftCenter",
        x_base=0.0,
        y_base=0.0,
        z_base=0.0,
        make_pressure_treated=False,
        use_debug_colors=False,
    )
    rotate_rear_wall_90(rear_left_center, x_offset_ft=wall_module_width_ft)
    rear_wall_assemblies.append(rear_left_center)

    # Right-center module (sliding door)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear wall right-center module (door)...\n")
    rear_right_center = wa.create_sliding_door_72x80(
        doc,
        catalog_rows,
        assembly_name="Rear_Wall_RightCenter",
        x_base=0.0,
        y_base=0.0,
        z_base=0.0,
        make_pressure_treated=False,
        use_debug_colors=False,
    )
    rotate_rear_wall_90(rear_right_center, x_offset_ft=wall_module_width_ft * 2.0)
    rear_wall_assemblies.append(rear_right_center)

    # Right module (window wall)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear wall right module (window)...\n")
    rear_right = wa.create_window_wall_double_3x5(
        doc,
        catalog_rows,
        assembly_name="Rear_Wall_Right",
        x_base=0.0,
        y_base=0.0,
        z_base=0.0,
        make_pressure_treated=False,
        use_debug_colors=False,
    )
    rotate_rear_wall_90(rear_right, x_offset_ft=wall_module_width_ft * 3.0)
    rear_wall_assemblies.append(rear_right)

    # Create Rear_Wall group
    rear_wall_grp = bc.create_group(doc, "Rear_Wall")
    bc.add_to_group(rear_wall_grp, rear_wall_assemblies)

    App.Console.PrintMessage(f"[Build_950Surf] Rear wall complete ({len(rear_wall_assemblies)} modules).\n")

    # Add both walls to First_Floor parent group
    bc.add_to_group(first_floor_parent, [front_wall_grp, rear_wall_grp])
    App.Console.PrintMessage("[Build_950Surf] Walls organized under First_Floor.\n")

# ============================================================
# SECTION 9: DECK SURFACE (boards and posts, installed AFTER walls)
# ============================================================

if BUILD.get("include_deck_surface", False):
    App.Console.PrintMessage("[Build_950Surf] Building deck surface (boards, no posts)...\n")

    deck_surface_assemblies = []

    # Front deck surface (3 modules using config dimensions)
    # Only outermost modules get edge boards
    App.Console.PrintMessage("[Build_950Surf]   Creating front deck surface (3 modules from config)...\n")
    front_deck_surface_left = da.create_deck_surface_16x8(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Surface_Left",
        x_base=deck_left_x_ft * 12.0,
        y_base=front_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=True,   # Outermost left edge
        include_right_edge=False,  # Interior edge
    )
    deck_surface_assemblies.append(front_deck_surface_left)

    front_deck_surface_center = da.create_deck_surface_8ft9in_x_8ft(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Surface_Center",
        x_base=(deck_left_x_ft + module_16_width_ft) * 12.0,
        y_base=front_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=False,  # Interior (no edge boards on center module)
        include_right_edge=False,
    )
    deck_surface_assemblies.append(front_deck_surface_center)

    front_deck_surface_right = da.create_deck_surface_16x8(
        doc,
        catalog_rows,
        assembly_name="Front_Deck_Surface_Right",
        x_base=(deck_left_x_ft + module_16_width_ft + center_module_width_ft) * 12.0,
        y_base=front_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=False,  # Interior edge
        include_right_edge=True,   # Outermost right edge
    )
    deck_surface_assemblies.append(front_deck_surface_right)

    # Rear deck surface (3 modules using config dimensions)
    App.Console.PrintMessage("[Build_950Surf]   Creating rear deck surface (3 modules from config)...\n")
    rear_deck_surface_left = da.create_deck_surface_16x8(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Surface_Left",
        x_base=deck_left_x_ft * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=True,   # Outermost left edge
        include_right_edge=False,  # Interior edge
    )
    deck_surface_assemblies.append(rear_deck_surface_left)

    rear_deck_surface_center = da.create_deck_surface_8ft9in_x_8ft(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Surface_Center",
        x_base=(deck_left_x_ft + module_16_width_ft) * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=False,  # Interior (no edge boards on center module)
        include_right_edge=False,
    )
    deck_surface_assemblies.append(rear_deck_surface_center)

    rear_deck_surface_right = da.create_deck_surface_16x8(
        doc,
        catalog_rows,
        assembly_name="Rear_Deck_Surface_Right",
        x_base=(deck_left_x_ft + module_16_width_ft + center_module_width_ft) * 12.0,
        y_base=rear_deck_y_ft * 12.0,
        z_base=deck_z_base_in,
        supplier="lowes",
        include_left_edge=False,  # Interior edge
        include_right_edge=True,   # Outermost right edge
    )
    deck_surface_assemblies.append(rear_deck_surface_right)

    # TODO: Add perpendicular deck boards on ~4' overhangs (left and right of walls)

    # Create Deck_Surface group
    deck_surface_grp = bc.create_group(doc, "Deck_Surface")
    bc.add_to_group(deck_surface_grp, deck_surface_assemblies)

    App.Console.PrintMessage(f"[Build_950Surf] Deck surface complete ({len(deck_surface_assemblies)} modules).\n")
else:
    App.Console.PrintMessage("[Build_950Surf] Deck surface skipped (disabled in BUILD config)\n")

# ============================================================
# FINAL RECOMPUTE
# ============================================================

App.Console.PrintMessage("[Build_950Surf] Recomputing document...\n")
bc.recompute_once(doc)
App.Console.PrintMessage("[Build_950Surf] Build complete!\n")

# ============================================================
# FINALIZE VIEW (show all, hide helpers, fit camera)
# ============================================================

App.Console.PrintMessage("[Build_950Surf] Finalizing view (show model, hide origins/axes)...\n")

# Show all model objects, hide LCS (Local Coordinate System) helpers
for obj in doc.Objects:
    try:
        type_id = obj.TypeId
        is_helper = (
            type_id == "PartDesign::CoordinateSystem"
            or type_id in ["PartDesign::Plane", "App::Plane", "App::Origin", "App::Line", "App::Axis"]
            or "Axis" in obj.Name
            or "Origin" in obj.Name
        )

        # Set visibility (hide helpers, show everything else)
        if hasattr(obj, "Visibility"):
            obj.Visibility = not is_helper
        if hasattr(obj, "ViewObject") and hasattr(obj.ViewObject, "Visibility"):
            obj.ViewObject.Visibility = not is_helper
    except Exception:
        pass

# Set camera view (if GUI available)
try:
    import FreeCADGui as Gui
    if Gui.ActiveDocument:
        v = Gui.ActiveDocument.ActiveView
        v.setCameraType("Orthographic")
        v.viewIsometric()
        v.fitAll()
        App.Console.PrintMessage("[Build_950Surf] Camera set to isometric and fit.\n")
except Exception:
    pass

# ============================================================
# SAVE DOCUMENT (if path specified via environment)
# ============================================================

save_path = os.environ.get("LUMBER_SAVE_FCSTD")
if save_path:
    try:
        doc.saveAs(save_path)
        App.Console.PrintMessage(f"[Build_950Surf] Saved model to {save_path}\n")
    except Exception as e:
        App.Console.PrintError(f"[Build_950Surf] Failed to save model to {save_path}: {e}\n")
