#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Headless snapshot for foundation (piles + beams + blocking + lot lines).
Reads SNAPSHOT_INPUT (FCStd) and writes SNAPSHOT_IMAGE (PNG) using Pillow.

Draws:
  - Lot and buildable area outlines
  - Piles (with dimensions)
  - Beams (green rectangles)
  - Blocking (orange rectangles)
  - Pile spacing dimensions
  - Offsets from lot edges

For Luke Dombrowski. Stay Alive.
"""

import os
import math
import FreeCAD as App

try:
    from PIL import Image, ImageDraw, ImageFont
except Exception as exc:
    raise RuntimeError(f"Pillow not available for snapshot generation: {exc}")

input_path = os.environ.get("SNAPSHOT_INPUT")
output_path = os.environ.get("SNAPSHOT_IMAGE")

if not input_path or not os.path.isfile(input_path):
    raise RuntimeError("SNAPSHOT_INPUT missing or file not found")
if not output_path:
    raise RuntimeError("SNAPSHOT_IMAGE not set")

doc = App.openDocument(input_path)
App.setActiveDocument(doc.Name)

pile_boxes = []
beam_boxes = []
blocking_boxes = []
drain_pipe_boxes = []
lot_box = None
build_box = None

# Recursively find objects in groups
def find_objects_recursive(obj_list):
    """Recursively traverse groups to find all foundation objects."""
    for obj in obj_list:
        try:
            if hasattr(obj, 'Group') and obj.Group:
                # Recursively search inside groups
                find_objects_recursive(obj.Group)
            elif hasattr(obj, 'Shape') and obj.Shape:
                # Check object type by name
                if obj.Name == "Lot_Boundary":
                    global lot_box
                    lot_box = obj.Shape.BoundBox
                elif obj.Name == "Buildable_Area":
                    global build_box
                    build_box = obj.Shape.BoundBox
                elif obj.Name.startswith("Pile_"):
                    pile_boxes.append(obj.Shape.BoundBox)
                elif "Beam_" in obj.Name:
                    beam_boxes.append(obj.Shape.BoundBox)
                elif "Blocking_" in obj.Name:
                    blocking_boxes.append(obj.Shape.BoundBox)
                elif "Drain_Pipe_" in obj.Name or "Drain_Coupling_" in obj.Name:
                    drain_pipe_boxes.append(obj.Shape.BoundBox)
        except Exception:
            pass

# Start recursive search from top-level objects
find_objects_recursive(doc.Objects)

if not pile_boxes:
    App.Console.PrintError("[snapshot_foundation] No piles found; skipping image\n")
    App.closeDocument(doc.Name)
    raise SystemExit(0)

App.Console.PrintMessage(
    f"[snapshot_foundation] Found: {len(pile_boxes)} piles, "
    f"{len(beam_boxes)} beams, {len(blocking_boxes)} blocking pieces, "
    f"{len(drain_pipe_boxes)} drain pipe sections\n"
)

# Calculate pile positions for spacing dimensions
xs = sorted({bb.Center.x for bb in pile_boxes})
ys = sorted({bb.Center.y for bb in pile_boxes})
spacings_x = [xs[i+1] - xs[i] for i in range(len(xs)-1)] if len(xs) > 1 else []
spacings_y = [ys[i+1] - ys[i] for i in range(len(ys)-1)] if len(ys) > 1 else []

# Compute drawing bounds
all_boxes = list(pile_boxes) + list(beam_boxes) + list(blocking_boxes) + list(drain_pipe_boxes)
if lot_box:
    all_boxes.append(lot_box)
if build_box:
    all_boxes.append(build_box)

min_x = min(bb.XMin for bb in all_boxes)
max_x = max(bb.XMax for bb in all_boxes)
min_y = min(bb.YMin for bb in all_boxes)
max_y = max(bb.YMax for bb in all_boxes)

pad_mm = 500.0
span_x = max_x - min_x
span_y = max_y - min_y
img_size = 2400
draw_span_x = span_x + 2 * pad_mm
draw_span_y = span_y + 2 * pad_mm
scale = min((img_size - 40) / draw_span_x, (img_size - 40) / draw_span_y)
if not math.isfinite(scale) or scale <= 0:
    scale = 1.0

def map_point(x_mm, y_mm):
    px = int(round((x_mm - min_x + pad_mm) * scale + 20))
    py = int(round((max_y + pad_mm - y_mm) * scale + 20))
    return px, py

img = Image.new("RGB", (img_size, img_size), "white")
draw = ImageDraw.Draw(img)

# Load font
try:
    font = ImageFont.truetype("Arial", 24)
    font_small = ImageFont.truetype("Arial", 18)
except Exception:
    font = ImageFont.load_default()
    font_small = ImageFont.load_default()

# Draw lot/buildable outlines
def draw_rect(bb, outline, width=2, label=None):
    x0, y0 = map_point(bb.XMin, bb.YMin)
    x1, y1 = map_point(bb.XMax, bb.YMax)
    xa, xb = sorted((x0, x1))
    ya, yb = sorted((y0, y1))
    draw.rectangle([(xa, ya), (xb, yb)], outline=outline, width=width)
    if label:
        draw.text((xa + 5, ya + 5), label, fill=outline, font=font_small)

if lot_box:
    draw_rect(lot_box, outline="#999999", width=3, label="Lot")
if build_box:
    draw_rect(build_box, outline="#5555aa", width=2, label="Buildable")

# Draw blocking (below beams for visibility)
for bb in blocking_boxes:
    x0, y0 = map_point(bb.XMin, bb.YMin)
    x1, y1 = map_point(bb.XMax, bb.YMax)
    xa, xb = sorted((x0, x1))
    ya, yb = sorted((y0, y1))
    draw.rectangle([(xa, ya), (xb, yb)], outline="#FF8C00", fill="#FFD580", width=1)

# Draw beams (below piles for visibility)
for bb in beam_boxes:
    x0, y0 = map_point(bb.XMin, bb.YMin)
    x1, y1 = map_point(bb.XMax, bb.YMax)
    xa, xb = sorted((x0, x1))
    ya, yb = sorted((y0, y1))
    draw.rectangle([(xa, ya), (xb, yb)], outline="darkgreen", fill="#90EE90", width=2)

# DEBUG: Log pile position for comparison with drain pipe
if pile_boxes:
    # Find the northeast corner pile (max X, max Y among first few piles)
    ne_pile = max(pile_boxes, key=lambda bb: (bb.Center.x, bb.Center.y))
    App.Console.PrintMessage(
        f"[DEBUG snapshot] NE corner pile: Y range {ne_pile.YMin/304.8:.5f}' to {ne_pile.YMax/304.8:.5f}', "
        f"center={ne_pile.Center.y/304.8:.5f}'\n"
    )

# Draw drain pipes (cyan/blue, above beams but below piles)
for i, bb in enumerate(drain_pipe_boxes):
    # DEBUG: Log bounding box Y coordinates
    if i == 0:  # Only log first vertical pipe
        App.Console.PrintMessage(
            f"[DEBUG snapshot] Drain pipe 0: Y range {bb.YMin/304.8:.5f}' to {bb.YMax/304.8:.5f}', "
            f"center={(bb.YMin + bb.YMax)/2.0/304.8:.5f}'\n"
        )
        App.Console.PrintMessage(
            f"[DEBUG snapshot] Offset from pile center: {(bb.Center.y - ne_pile.Center.y)/304.8:.5f}' "
            f"({(bb.Center.y - ne_pile.Center.y)/25.4:.2f} inches)\n"
        )

    x0, y0 = map_point(bb.XMin, bb.YMin)
    x1, y1 = map_point(bb.XMax, bb.YMax)
    xa, xb = sorted((x0, x1))
    ya, yb = sorted((y0, y1))
    # Draw as circles for vertical pipes, rectangles for horizontal
    if abs(xa - xb) < 5 and abs(ya - yb) < 5:  # Vertical pipe (top-down view)
        # Draw as filled circle
        center_x = (xa + xb) // 2
        center_y = (ya + yb) // 2
        radius = max(3, int((xb - xa) / 2))
        draw.ellipse([(center_x - radius, center_y - radius),
                      (center_x + radius, center_y + radius)],
                     outline="#0080FF", fill="#80C0FF", width=2)
    else:  # Horizontal pipe
        draw.rectangle([(xa, ya), (xb, yb)], outline="#0080FF", fill="#80C0FF", width=2)

# Draw piles (on top)
for bb in pile_boxes:
    x0, y0 = map_point(bb.XMin, bb.YMin)
    x1, y1 = map_point(bb.XMax, bb.YMax)
    xa, xb = sorted((x0, x1))
    ya, yb = sorted((y0, y1))
    draw.rectangle([(xa, ya), (xb, yb)], outline="black", fill="#c5d8ff", width=2)

# Annotate counts
text_lines = [
    f"Piles: {len(pile_boxes)}",
    f"Beams: {len(beam_boxes)}",
    f"Blocking: {len(blocking_boxes)}",
    f"Drain: {len(drain_pipe_boxes)} sections"
]
if spacings_x:
    text_lines.append(f"Pile X: {spacings_x[0]/304.8:.1f} ft OC")
if spacings_y:
    text_lines.append(f"Pile Y: {spacings_y[0]/304.8:.1f} ft OC")

text = " | ".join(text_lines)
draw.text((30, 30), text, fill="black", font=font)

# Dimension helpers
def draw_h_dim(y_mm, x0_mm, x1_mm, label):
    p0 = map_point(x0_mm, y_mm)
    p1 = map_point(x1_mm, y_mm)
    draw.line([p0, p1], fill="red", width=2)
    mid = ((p0[0]+p1[0])//2, (p0[1]+p1[1])//2 - 12)
    draw.text(mid, label, fill="red", font=font_small)

def draw_v_dim(x_mm, y0_mm, y1_mm, label):
    p0 = map_point(x_mm, y0_mm)
    p1 = map_point(x_mm, y1_mm)
    draw.line([p0, p1], fill="red", width=2)
    mid = (p0[0]+8, (p0[1]+p1[1])//2 - 12)
    draw.text(mid, label, fill="red", font=font_small)

# Draw pile spacing dimensions (X direction)
gap_y_mm = min_y - pad_mm * 0.25
for i, gap in enumerate(spacings_x):
    draw_h_dim(gap_y_mm - i * 40, xs[i], xs[i+1], f"{gap/304.8:.1f}'")

# Draw pile spacing dimensions (Y direction)
gap_x_mm = min_x - pad_mm * 0.3
for i, gap in enumerate(spacings_y):
    draw_v_dim(gap_x_mm - i * 40, ys[i], ys[i+1], f"{gap/304.8:.1f}'")

# Offsets to lot edges if lot is present
if lot_box and pile_boxes:
    lot_left = lot_box.XMin
    lot_right = lot_box.XMax
    lot_front = lot_box.YMin
    lot_back = lot_box.YMax
    pile_half_w = pile_boxes[0].XLength / 2.0
    pile_half_t = pile_boxes[0].YLength / 2.0
    offset_left = (xs[0] - pile_half_w) - lot_left
    offset_right = lot_right - (xs[-1] + pile_half_w)
    offset_front = (ys[0] - pile_half_t) - lot_front
    offset_back = lot_back - (ys[-1] + pile_half_t)

    draw_h_dim(min_y - pad_mm * 0.65, lot_left, lot_left + offset_left,
               f"L: {offset_left/304.8:.1f}'")
    draw_h_dim(min_y - pad_mm * 0.7, lot_right - offset_right, lot_right,
               f"R: {offset_right/304.8:.1f}'")
    draw_v_dim(min_x - pad_mm * 0.65, lot_front, lot_front + offset_front,
               f"F: {offset_front/304.8:.1f}'")
    draw_v_dim(min_x - pad_mm * 0.7, lot_back - offset_back, lot_back,
               f"B: {offset_back/304.8:.1f}'")

img.save(output_path)
App.Console.PrintMessage(f"[snapshot_foundation] Saved image to {output_path}\n")

App.closeDocument(doc.Name)
