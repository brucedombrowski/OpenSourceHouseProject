import os
import math
import FreeCAD as App

try:
    from PIL import Image, ImageDraw, ImageFont
except Exception as exc:
    raise RuntimeError(f"Pillow not available for snapshot generation: {exc}")

"""
Headless snapshot for pile spacing + lot lines.
Reads SNAPSHOT_INPUT (FCStd) and writes SNAPSHOT_IMAGE (PNG) using Pillow.
Draws:
  - Lot and buildable area outlines (if present)
  - Piles
  - Per-interval spacing in X and Y (center-to-center)
  - Offsets from lot edges to first/last pile centers
No FreeCADGui dependency; intended to run under FreeCADCmd.
"""

input_path = os.environ.get("SNAPSHOT_INPUT")
output_path = os.environ.get("SNAPSHOT_IMAGE")

if not input_path or not os.path.isfile(input_path):
    raise RuntimeError("SNAPSHOT_INPUT missing or file not found")
if not output_path:
    raise RuntimeError("SNAPSHOT_IMAGE not set")

doc = App.openDocument(input_path)
App.setActiveDocument(doc.Name)

pile_boxes = []
beam_boxes = []
lot_box = None
build_box = None
for obj in doc.Objects:
    try:
        if obj.Name == "Lot_Boundary":
            lot_box = obj.Shape.BoundBox
        elif obj.Name == "Buildable_Area":
            build_box = obj.Shape.BoundBox
        elif obj.Name.startswith("Pile_"):
            # Only include actual pile objects (square cross-section, tall)
            bb = obj.Shape.BoundBox
            # Piles are ~11.25" square (285.75mm) and tall (40'+ = 12000mm+)
            # Filter out any non-pile objects that happen to start with "Pile_"
            if bb.ZLength > 1000 and abs(bb.XLength - bb.YLength) < 50:
                pile_boxes.append(bb)
            else:
                App.Console.PrintMessage(f"[snapshot_pile_spacing] Skipping non-pile object: {obj.Name} ({bb.XLength:.1f}x{bb.YLength:.1f}x{bb.ZLength:.1f}mm)\n")
        elif obj.Name.startswith("Beam_"):
            bb = obj.Shape.BoundBox
            beam_boxes.append(bb)
    except Exception:
        pass

if not pile_boxes:
    App.Console.PrintError("[snapshot_pile_spacing] No piles found; skipping image\n")
    App.closeDocument(doc.Name)
    raise SystemExit(0)

# Round positions to nearest 0.1mm to eliminate floating point noise
# (0.1mm â‰ˆ 0.004" - well below construction tolerance)
def round_mm(val):
    return round(val, 1)

xs = sorted({round_mm(bb.Center.x) for bb in pile_boxes})
ys = sorted({round_mm(bb.Center.y) for bb in pile_boxes})
App.Console.PrintMessage(f"[snapshot_pile_spacing] Piles={len(pile_boxes)}, xs={len(xs)}, ys={len(ys)}\n")
spacings_x = [xs[i+1] - xs[i] for i in range(len(xs)-1)]
spacings_y = [ys[i+1] - ys[i] for i in range(len(ys)-1)]
if spacings_x:
    App.Console.PrintMessage(f"[snapshot_pile_spacing] First X spacing: {spacings_x[0]:.3f} mm ({spacings_x[0]/304.8:.3f} ft)\n")
if spacings_y:
    App.Console.PrintMessage(f"[snapshot_pile_spacing] First Y spacing: {spacings_y[0]:.3f} mm ({spacings_y[0]/304.8:.3f} ft)\n")

# Compute drawing bounds
all_boxes = list(pile_boxes)
for box in (lot_box, build_box):
    if box:
        all_boxes.append(box)
min_x = min(bb.XMin for bb in all_boxes)
max_x = max(bb.XMax for bb in all_boxes)
min_y = min(bb.YMin for bb in all_boxes)
max_y = max(bb.YMax for bb in all_boxes)

pad_mm = 500.0
span_x = max_x - min_x
span_y = max_y - min_y
img_size = 2000
draw_span_x = span_x + 2 * pad_mm
draw_span_y = span_y + 2 * pad_mm
scale = min((img_size - 40) / draw_span_x, (img_size - 40) / draw_span_y)
if not math.isfinite(scale) or scale <= 0:
    scale = 1.0

def map_point(x_mm, y_mm):
    px = int(round((x_mm - min_x + pad_mm) * scale + 20))
    py = int(round((max_y + pad_mm - y_mm) * scale + 20))
    return px, py

img = Image.new("RGB", (img_size, img_size), "white")
draw = ImageDraw.Draw(img)

# Draw lot/buildable outlines
def draw_rect(bb, outline, width=2, dash=False):
    x0, y0 = map_point(bb.XMin, bb.YMin)
    x1, y1 = map_point(bb.XMax, bb.YMax)
    xa, xb = sorted((x0, x1))
    ya, yb = sorted((y0, y1))
    if dash:
        draw.rectangle([(xa, ya), (xb, yb)], outline=outline, width=width)
    else:
        draw.rectangle([(xa, ya), (xb, yb)], outline=outline, width=width)

if lot_box:
    draw_rect(lot_box, outline="#999999", width=3)
    draw.text(map_point(lot_box.XMin, lot_box.YMax), "Lot", fill="black", font=ImageFont.load_default())
if build_box:
    draw_rect(build_box, outline="#5555aa", width=2)
    draw.text(map_point(build_box.XMin, build_box.YMax), "Buildable", fill="black", font=ImageFont.load_default())

# Draw beams as rectangles (below piles for visibility)
for bb in beam_boxes:
    x0, y0 = map_point(bb.XMin, bb.YMin)
    x1, y1 = map_point(bb.XMax, bb.YMax)
    xa, xb = sorted((x0, x1))
    ya, yb = sorted((y0, y1))
    draw.rectangle([(xa, ya), (xb, yb)], outline="darkgreen", fill="#90EE90", width=2)

# Draw piles as rectangles (on top of beams)
for bb in pile_boxes:
    x0, y0 = map_point(bb.XMin, bb.YMin)
    x1, y1 = map_point(bb.XMax, bb.YMax)
    xa, xb = sorted((x0, x1))
    ya, yb = sorted((y0, y1))
    draw.rectangle([(xa, ya), (xb, yb)], outline="black", fill="#c5d8ff")

# Annotate spacing text
try:
    font = ImageFont.truetype("Arial", 28)
except Exception:
    font = ImageFont.load_default()

text_lines = [f"Piles: {len(pile_boxes)}", f"Beams: {len(beam_boxes)}"]
if spacings_x:
    text_lines.append(f"X spacing first: {spacings_x[0]/304.8:.3f} ft")
if spacings_y:
    text_lines.append(f"Y spacing first: {spacings_y[0]/304.8:.3f} ft")
text = " | ".join(text_lines) if text_lines else "Pile spacing snapshot"
draw.text((30, 30), text, fill="black", font=font)

# Dimension helpers
def draw_h_dim(y_mm, x0_mm, x1_mm, label, text_offset_y=0):
    p0 = map_point(x0_mm, y_mm)
    p1 = map_point(x1_mm, y_mm)
    draw.line([p0, p1], fill="red", width=3)
    # Position text centered on line, offset below
    mid_x = (p0[0] + p1[0]) // 2
    mid_y = (p0[1] + p1[1]) // 2 + 20 + text_offset_y  # Below the line
    draw.text((mid_x - 40, mid_y), label, fill="red", font=font)

def draw_v_dim(x_mm, y0_mm, y1_mm, label, text_offset_x=0):
    p0 = map_point(x_mm, y0_mm)
    p1 = map_point(x_mm, y1_mm)
    draw.line([p0, p1], fill="red", width=3)
    # Position text centered on line, offset to the left
    mid_y = (p0[1] + p1[1]) // 2
    draw.text((p0[0] - 120 + text_offset_x, mid_y - 10), label, fill="red", font=font)

# Draw per-gap X dimensions (center to center)
# Show full precision, use ~ prefix if not a clean number
def format_ft(mm_val):
    ft_val = mm_val / 304.8
    # Check if it's a clean number (within 0.001 of a 1/8" increment)
    eighths = ft_val * 96
    if abs(eighths - round(eighths)) < 0.1:
        return f"{ft_val:.2f} ft"
    else:
        return f"~{ft_val:.2f} ft"

# Stagger text vertically to avoid overlap (35 pixels per row)
text_row_height = 35
gap_y_mm = min_y - pad_mm * 0.2
for i, gap in enumerate(spacings_x):
    # Stagger: even indices on row 0, odd on row 1
    row = i % 2
    draw_h_dim(gap_y_mm, xs[i], xs[i+1], format_ft(gap), text_offset_y=row * text_row_height)

# Draw per-gap Y dimensions (all aligned on same X)
gap_x_mm = min_x - pad_mm * 0.25
for i, gap in enumerate(spacings_y):
    draw_v_dim(gap_x_mm, ys[i], ys[i+1], format_ft(gap))

# Offsets to lot edges if lot is present
if lot_box:
    lot_left = lot_box.XMin
    lot_right = lot_box.XMax
    lot_front = lot_box.YMin
    lot_back = lot_box.YMax
    half_w_mm = pile_boxes[0].XLength / 2.0
    half_t_mm = pile_boxes[0].YLength / 2.0
    offset_left = (xs[0] - half_w_mm) - lot_left
    offset_right = lot_right - (xs[-1] + half_w_mm)
    offset_front = (ys[0] - half_t_mm) - lot_front
    offset_back = lot_back - (ys[-1] + half_t_mm)
    # Use same format_ft function for offsets
    # Offset labels on separate rows from pile spacing labels
    draw_h_dim(gap_y_mm, lot_left, lot_left + offset_left, f"Offset left: {format_ft(offset_left)}", text_offset_y=2 * text_row_height)
    draw_h_dim(gap_y_mm, lot_right - offset_right, lot_right, f"Offset right: {format_ft(offset_right)}", text_offset_y=2 * text_row_height)
    draw_v_dim(gap_x_mm, lot_front, lot_front + offset_front, f"Offset front: {format_ft(offset_front)}")
    draw_v_dim(gap_x_mm, lot_back - offset_back, lot_back, f"Offset back: {format_ft(offset_back)}")

img.save(output_path)
App.Console.PrintMessage(f"[snapshot_pile_spacing] Saved image to {output_path}\n")

App.closeDocument(doc.Name)
